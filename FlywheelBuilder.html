<!DOCTYPE html>
<html>
<head>
<title>Flywheel Builder</title>
<!-- Copyright (C) 2015 Todd Inglett -->
<!-- License GPLv2.  See https://gnu.org/licenses/old-licenses/gpl-2.0.txt -->
<!--
For now, see the discussion at http://www.modelenginemaker.com/index.php/topic,5078.0.html
for some background and instructions on using this application.

This is fairly new and not well tested.  Double check everything and certainly
verify cuts look correct as you setup your mill.  Instructions for safely
using a mill and lathe are not covered here.  If you are just starting out,
try asking questions of all the fine and helpful people you will find at
http://www.modelenginemaker.com and you won't be disappointed!

Todd
 -->
<style>
table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
}
</style>
</head>

<body onLoad="buildFlywheels()">
<h2>Flywheel builder v1.3</h2>
<form name="flywheelParms" onChange="buildFlywheels()">
<!-- Use a select for spokes so crazy numbers (like fractions) can't happen -->
<canvas id="flywheelDemoCanvas" width="400" height="400"
  style="border:1px solid #d3d3d3;">
Your browser does not support the canvas element.  Sorry, this web page won't work for you.
</canvas>
<canvas id="flywheelDimsCanvas" width="400" height="400"
  style="border:1px solid #d3d3d3;">
</canvas>
<p><b>Dimensions:   </b>
Spokes: <select id="flywheelSpokes">
		<option value="3">3</option>
		<option value="4">4</option>
		<option value="5" selected>5</option>
		<option value="6">6</option>
		</select>
Units: <select id="flywheelUnits">
		<option value="mm">mm</option>
		<option value="in" selected>inches</option>
		</select>
Presets:  <select id="flywheelPresets" onchange="selectedPreset()">
		<option value="">Choose a Pre-designed Flywheel</option>
		<option value="spokes=6&units=in&dia=2.5&rim=0.25&hub=0.500&shaft=0.250&india=0.250&outdia=0.125&indis=0.438&outdis=0.875&inang=30.0&outang=8.2">
		2.5" Diameter 6-spoke from Elmers #24 Beam</option>
		<option value="spokes=4&units=in&dia=3.0&rim=0.375&hub=0.625&shaft=0.250&india=0.250&outdia=0.250&indis=0.438&outdis=1.000&inang=32.0&outang=12.0">
		3" Diameter 4-spoke Simple</option>
		<option value="spokes=6&units=in&dia=3.0&rim=0.375&hub=0.500&shaft=0.250&india=0.188&outdia=0.125&indis=0.438&outdis=1.000&inang=30.0&outang=9.0">
		3" Diameter 6-spoke from Elmer's #5 Geared</option>
		<option value="spokes=5&units=in&dia=4.0&rim=0.312&hub=0.625&shaft=0.313&india=0.375&outdia=0.188&indis=0.625&outdis=1.438&inang=36.0&outang=8.0">
		4" Diameter 5-spoke Thick</option>
		<option value="spokes=5&units=in&dia=4.0&rim=0.188&hub=0.625&shaft=0.313&india=0.375&outdia=0.188&indis=0.625&outdis=1.625&inang=36.0&outang=8.0">
		4" Diameter 5-spoke Thin</option>
		<option value="spokes=6&units=in&dia=5.0&rim=0.094&hub=0.875&shaft=0.375&india=0.625&outdia=0.188&indis=0.875&outdis=2.125&inang=30.0&outang=6.0">
		5.0" 6-spoke Easton &amp; Anderson Grasshopper</option>
		<option value="spokes=6&units=in&dia=6.5&rim=0.250&hub=0.625&shaft=0.313&india=0.25&outdia=0.188&indis=0.625&outdis=2.75&inang=24&outang=4.6">
		6.5" Diameter 6-spoke Thin</option>


		</select>
		
<input id="prevFlywheelSpokes" value="0" hidden>
<input id="prevFlywheelUnits" value="none" hidden>
<input id="urlhash" value="" hidden>

<table style="text-align: left">
<tr><td>Flywheel diameter </td> <td><input id="flywheelDiameter" type="text" value="4.000" size="4" maxlength="8"></td>
    <td>Rim Thickness </td> <td><input id="flywheelRimThick" type="text" value="0.312" size="4" maxlength="8"></td></tr>
<tr><td>Hub diameter     </td> <td><input id="flywheelHubDiameter" type="text" value="0.625" size="4" maxlength="8"></td>
    <td>Shaft diameter   </td> <td><input id="flywheelShaftDiameter" type="text" value="0.313" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole diameter</td> <td><input id="flywheelInnerHoleDiameter" type="text" value="0.375" size="4" maxlength="8"></td>
    <td>Outer hole diameter</td> <td><input id="flywheelOuterHoleDiameter" type="text" value="0.188" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole distance</td> <td><input id="flywheelInnerHoleDistance" type="text" value="0.625" size="4" maxlength="8"></td>
    <td>Outer hole distance</td> <td><input id="flywheelOuterHoleDistance" type="text" value="1.438" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole angle</td> <td><input id="flywheelInnerHoleAngle" type="text" value="36.0" size="4" maxlength="8"></td>
    <td>Outer hole angle</td> <td><input id="flywheelOuterHoleAngle" type="text" value="8.0" size="4" maxlength="8"></td></tr>
</table>
</form>

<p>
The inner spoke thickness is <b id="InnerThick">0</b> and the outer spoke
thickness is <b id="OuterThick">0</b>.  Use an inner hole angle of <b id="ThreeHoleAngle"></b> to have a 3-hole web cutout.
<p>
The rotary table must be rotated <b id="RTrotate">0</b> degrees clockwise to bring the
spoke edge parallel to the mill axis.  The table must be offset by
x=<b id="RToffset">0</b> plus half the cutter diameter.  See the step-by-step
instructions below to build this particular flywheel design.

<h1>Fabrication of this Flywheel</h1>
This generated guide provides instructions for cutting out the web in the flywheel design shown above.
This guide does not cover details of the Z dimension.  It is expected the flywheel will initially be
turned on the lathe.  Face the flywheel on both sides.  Bore the axle hole, which could be smaller
than the final hole if the flywheel must be fitted to a mandrel or fitted for a guide for centering on the rotary
table (RT).  Trepan the flywheel.  i.e., turn the webs in preparation for the cutout procedure below.
The flywheel can return to the lathe after performing the web cutouts if desired.

<h2>Orientation</h2>
Note that the angles for the flywheel are dimensioned such that 0 degrees is pointing "up."  When the flywheel
is centered on an RT on the mill, this "up" direction could be aligned with either the Y axis or the X axis.  Which
axis is used does really matter, so the instructions from here on will be vague about this.  There may be a
slight advantage to using X as cutting operation may be easier to see.
<p>
In these instructions spokes are numbered from 1, which is the spoke facing "up," and they go around in a clockwise
direction.  In general the web cutouts will be performed in a clockwise direction for this reason.  If for some reason
your rotary table works better counterclockwise, there is no reason that can't be done.  Just be consistent to avoid
backlash and, more importantly, confusion.
<p>
Here are the spoke angles for this particular flywheel design.  Cuts will not be performed directly along these angles
as these identify the centerlines of the spokes, but it should be noted that often moving from one position to another
will span this angle increment.  <b>Hint:</b> the angles are greatly simplified if they are a multiple of the turn
of a crank on the RT.  This may be something like 4 degrees.  The design of the flywheel can usually be tweaked so
this is the case, and working the RT becomes much easier.
<p>
Finally, note that degrees are shown rounded to tenths.  A tenth of a degree is 6 minutes, 0 seconds.  This
should be accurate enough for flywheel web cutouts.

<table id="spokeTable"  style="text-align: right; width: 10em;">
<caption><b>Table 1: Spoke angles</b></caption>
<tr><th>Spoke</th><th>Angle</th></tr>
</table>

<h2>Order of Operations</h2>
There are many ways to cut out the webs of the flywheel, but this ordering works well and is what will be described here.
As mentioned earlier, it is assumed the flywheel has been faced and trepanned on the lathe, and a center bore has been
made, whether sized for the final axle or not, so that the flywheel webs can be cut.  The center hole will be the key datum
from which measurements will be made.
<ol>
<li>Drill the leftmost inner holes for the cutouts.
<li>Drill the rightmost inner holes for the cutouts (if there are any -- 3-hole cutouts are common).
<li>Drill the leftmost outer holes for the web cutouts.
<li>Drill the rightmost outer holes for the web cutouts.
<li>Cut the right (clockwise) side of each spoke.
<li>Cut the left side of each spoke.
<li>Cut the outer arc of the web cutout.
<li>Cut the inner arc if it is a 4-hole cutout.
</ol>

<h2>Setup</h2>
Center and clamp the flywheel on the RT.  The clamps must not obstruct drilling and cutting operations.
Center the RT under the mill.  Zero the RT and mark the flywheel so it is obvious where the 0 (spoke #1) is located.
Many operations will reset to this position as their first step.

<h2>Drill the Inner Holes</h2>
The inner holes for this flywheel design are <b id="inTabDia">0</b> diameter.  These holes will be drilled
at an offset <b id="inTabDist">0</b> from the center of the flywheel by
shifting the center of the rotary table in X or Y.  <span id="inTab4holeMsg"></span>
Advancing from hole to hole in this manner is done by rotating the RT <b id="instRTspokeAngle1">0</b> degrees for each.
Return the RT back to 0 degrees when done.
<p>
<table id="innerHoleTable" style="text-align: right; width: 12em;">
<caption><b>Table 2: Inner hole angles</b></caption>
<tr><th>Spoke</th><th colspan="2">Angle</th></tr>
</table>

<h2>Drill the Outer Holes</h2>
The outer holes are <b id="outTabDia">0</b> diameter.  These holes will be drilled
at an offset <b id="outTabDist">0</b> from the center of the flywheel by
shifting the center of the rotary table in X or Y.  Use care to reset the distance from the center
as the RT was offset for the previous drilling of inner holes.  It may be best to re-center the RT
and adjust the offset from there to avoid error.
<p>
There are two holes to drill on the clockwise side of each spoke.
The angles are listed. It is less error prone to drill the left hole for each spoke first, and then go around again drilling the right.
Advancing from hole to hole in this manner is done by rotating the RT <b id="instRTspokeAngle2">0</b> degrees for each.
Return the RT back to 0 degrees when done.
<p>
<table id="outerHoleTable"  style="text-align: right; width: 12em;">
<caption><b>Table 3: Outer hole angles</b></caption>
<tr><th>Spoke</th><th colspan="2">Angle</th></tr>
</table>

<h2>The Spoke Cutting</h2>
At the point the "corners" of the web cutouts have been defined with drilled holes.
Now the sides of the web cutouts along the spoke edges will be milled.  For best results,
use an end mill equal to or smaller than the smallest hole diameter.  The mill will cut from
an inner hole to the corresponding outer hole.
<p>
To position for this cut, start with spoke number 1 by ensuring the RT is centered
on the mill and returned to the zero position.  See the figure below for <b>Step 1</b>.
Now rotate the RT exactly
<b id="instRTrotate">0</b> degrees clockwise, which is a setting specific to this particular
flywheel design.  See the figure below for this clockwise rotation for <b>Step 2</b>.
The cut on the left side of the end mill should now be in
line to make this cut, except that the X or Y needs to be offset
by <b id="instRToffset">0</b> to account for the spoke thickness.
See the figure below for this sideways shift in <b>Step 3</b>.
Again, this
offset is specific to this flywheel design.  This offset must be further
increased by half the diameter (radius) of the end mill being used to cut the
spoke.  See the figure below for the end mill radius shift in <b>Step 4</b>.
<b>Don't forget to account for the cutter diameter!</b>
<p>
Before cutting, lower the mill head without plunging into either hole and verify
the cutter will cut from the left side of the inner hole to the left side of the
outer hole.  If all looks good, note the current Y (or X) position and slightly
increase the distance.  Now the cut can be made, potentially in multiple depth
passes depending on the capability of the mill.  Once it is completely cut
through, reset Y (or X) and make the final finish pass at the exact offset.
<p>
This cut the right side of spoke number 1.  Now use the RT to rotate past spoke
number 2 and do the same cut to the right of that spoke.  This will be a simple
<b id="instRTspokeAngle3">0</b> rotation from the current cut for this flywheel
design.  Don't change other settings, except jog the Y (or X) for the rough
cut vs. the finish cut.  Repeat until all the right sides of the spokes are cut.
<p>
<div style="float:left;">
<canvas id="instSpokeStep1Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 1: initial setup</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep2Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 2: rotate for cut</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep3Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 3: shift sideways</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep4Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 4: adjust for endmill</b>
</div>
<br style="clear: both">
<p>
Now the left side of each spoke must be cut.  <b>Return the RT back to zero.</b>
Now back up the RT by advancing clockwise <b id="instRTrotateLeft">0</b> degrees.
Now the right side of the end mill should be
in line to make this cut, except that the X or Y needs to be offset the other way
by <b id="instRToffsetBack">0</b> to account for the spoke thickness.  And again,
account for the end mill diameter by adjusting further for half the cutter diameter.
<p>
As before, lower the mill head without plunging into either hole and verify
the cutter will cut from the right side of the inner hole to the right side of the
outer hole.  If all looks good, note the current Y (or X) position and slightly
increase the distance.  Now the cut can be made, potentially in multiple depth
passes depending on the capability of the mill.  Once it is completely cut
through, reset Y (or X) and make the final finish pass at the exact offset.
Repeat until all the left sides of the spokes are cut.
<p>
The difficult part is done!

<h2>Finishing the Web</h2>
<span id="instFinish4WebMsg"></span>
<p>
Finish by cutting the outer arc.  Return the RT so that it and the flywheel
are centered under the mill. The outer arc of the web is at
<b id="instOuterArc">0</b> from the flywheel center.
This is the outer hole center distance of <b id="instOuterDist">0</b> plus
the radius of the outer hole which is  <b id="instOuterRadius">0</b>.
Offset X (or Y) by this amount, but reduced to account
for the end mill radius. Make the cut for each web being very careful NOT
to cut through a spoke!
<p>
That's it.  The flywheel may be removed from the
RT and cleaned up with files or further lathe operations.

<script>
"use strict";

var DEGSYM = "\u00B0";	// degree symbol in UTF-8 (unicode)
var units = "unknown";	// will be inches or mm
var angdigits = 1;		// Fixed at 1 decimal places for angles.
var lendigits = 0;		// will be 3 for inches and 2 for mm

/*
 * About the URL for FlywheelBuilder:
 *
 * The url uses a # sign to include input fields as part of the URL.
 * As input fields are changed while using this application, note that the
 * URL get updated to reflect the field changes.  This allows the browser
 * to bookmark the URL including the input fields.  Therefore different
 * types of flywheels may be saved.
 *
 * To keep the URL short, the input fields are given abbreviations.
 * These can get rather rough to sound out, but the following table maps
 * them (and is used by the code).
 */
 var urlstatemap = {
 	 // map 3-letter abbreviation to HTML form id names.
 	 spokes: "flywheelSpokes",
 	 units: "flywheelUnits",
 	 dia: "flywheelDiameter",
 	 rim: "flywheelRimThick",
 	 hub: "flywheelHubDiameter",
 	 shaft: "flywheelShaftDiameter",
 	 india: "flywheelInnerHoleDiameter",
 	 outdia: "flywheelOuterHoleDiameter",
 	 indis: "flywheelInnerHoleDistance",
 	 outdis: "flywheelOuterHoleDistance",
 	 inang: "flywheelInnerHoleAngle",
 	 outang: "flywheelOuterHoleAngle",
 };
 
 
 /*
  * This function parses the given location hash.
  * It uses urlstatemap to translate to HTML form ids, and it will
  * update the document elements with the values it finds in the
  * hash (#) part of the URL.
  *
  * So far all values are simple so no special quoting is needed.
  * If someone tries to hand-code a URL, it can easily be mucked up.
  */
 function parsehash(hash) {
 	 // chop off the # at the start of hash
 	 hash = hash.substr(1,hash.length-1);
  	 console.log("hash="+hash);

 	 // split the assignments apart
 	 var assignments = hash.split("&");
 	 for (var i in assignments) {
 	 	 // Now assignment[i] is a name=value pair
 	 	 var nameval = assignments[i].split("=");
 	 	 var field = urlstatemap[nameval[0]];
 	 	 if (field == undefined)	// just ignore invalid stuff
 	 	 	 continue;
 	 	 document.getElementById(field).value = nameval[1];
 	 }
 }
 
 /*
  * The reverse of parsehash.
  * This function iterates through urlstatemap and looks up each field
  * entry using the id name.  It then generates a hash that contains
  * assignments like this:
  *   #abc=value&xyz=value&jkl=value
  *
  * This string is returned.
  */
 function genhash() {
 	 var result = "";
 	 
 	 for (var id in urlstatemap) {
 	 	 var field = document.getElementById(urlstatemap[id]);
 	 	 if (result == "")
 	 	 	 result = "#";	// just starting
 	 	 else
 	 	 	 result += "&";	// another field
 	 	 result += id + "=" + field.value.trim();
 	 }
 	 return result;
 }
 
 /*
  * Handle a preset selection.
  *
  * This is incredibly easy.  The value of the preset selector box is the
  * hash part of the URL that contains all the parameters.  This makes it
  * easy to add presets by simply pasting the URL hash from a web browser
  * into this file, but it also makes this code trivial.
  *
  * To "load" the preset we set the current hash and we reset the hidden
  * urlhash field in the form.  The flywheel will update as a result of the
  * preset selector change, and buildFlywheels() will load the hash.
  */
 function selectedPreset() {
 	 location.hash = document.getElementById("flywheelPresets").value;
 	 document.getElementById("urlhash").value = "";
 }

/*
 * Build all the flywheel pictures here.
 *
 * We calculate everything once and then draw multiple views of it.
 * This will (help) keep all the data consistent between views.
 */
function buildFlywheels() {

	// Handle presets based on the url hash #xxx goop.
	// See parsehash() and genhash() functions for the format.
	var urlhash = document.getElementById("urlhash");
	if (urlhash.value == "") {
		// This hidden input field is empty so we are on the first load.
		// Parse out the URL for the # stuff and pre-fill the form.
		parsehash(location.hash);
		urlhash.value = location.hash;
	}
	
	// Before calculating and drawing the flywheel, do some measurement
	// handling (mm vs. inches).  This may not be the best thing to do, but if
	// the units is changed we automatically convert the units in the form.
	// Angles are always degrees, but length can be mm or inches.
	// The units and lendigits are global vars for now.
	var prevunits = document.getElementById("prevFlywheelUnits").value;
	units = document.getElementById("flywheelUnits").value;
	if (units == "mm")
		lendigits = 2;
	else if (units == "in")
		lendigits = 3;
	// Now that we have rounding established, do conversions if needed.
	if (prevunits != units) {
		var conv = 0;
		if (prevunits == "mm")
			conv = 1/25.4;
		else if (prevunits == "in")
			conv = 25.4;		// if neither, we get zero
		if (conv != 0) {
			// These are length fields to convert. Keeping this list is error prone.
			var fields = [
				"flywheelDiameter",
				"flywheelRimThick",
				"flywheelHubDiameter",
				"flywheelShaftDiameter",
				"flywheelInnerHoleDiameter",
				"flywheelInnerHoleDistance",
				"flywheelOuterHoleDiameter",
				"flywheelOuterHoleDistance"
			];
			var f;
			for (f in fields) {
				var v = document.getElementById(fields[f]).value;
				v = v * conv;
				document.getElementById(fields[f]).value = v.toFixed(lendigits);
			}
		}
	}
	document.getElementById("prevFlywheelUnits").value = units;

	//
	// Now calculate the flywheel from all the values in the form.
	//
	var spokes = parseInt(document.getElementById("flywheelSpokes").value);
	var flydia = parseFloat(document.getElementById("flywheelDiameter").value);
	var rim = parseFloat(document.getElementById("flywheelRimThick").value);
	var hubdia = parseFloat(document.getElementById("flywheelHubDiameter").value);
	var shaftdia = parseFloat(document.getElementById("flywheelShaftDiameter").value);
	
	var inholedia = parseFloat(document.getElementById("flywheelInnerHoleDiameter").value);
	var inholedist = parseFloat(document.getElementById("flywheelInnerHoleDistance").value);
	var inholeang = parseFloat(document.getElementById("flywheelInnerHoleAngle").value);

	var outholedia = parseFloat(document.getElementById("flywheelOuterHoleDiameter").value);
	var outholedist = parseFloat(document.getElementById("flywheelOuterHoleDistance").value);
	var outholeang = parseFloat(document.getElementById("flywheelOuterHoleAngle").value);
	
	// Some checks to "fix" invalid flywheels.  This doesn't cover them
	// all, by any means!
	var prevspokes = document.getElementById("prevFlywheelSpokes").value;
	if (prevspokes != spokes) {
		// If the previous # spokes had a 3-hole cutout then keep it that way.
		if (inholeang == 180/prevspokes) {
			inholeang = 180/spokes;
			document.getElementById("flywheelInnerHoleAngle").value = inholeang.toFixed(angdigits);
		}
	}
	document.getElementById("prevFlywheelSpokes").value = spokes;
	if (inholeang > 180/spokes) {
		inholeang = 180/spokes;
		document.getElementById("flywheelInnerHoleAngle").value = inholeang.toFixed(angdigits);
	}	
	
	var fly = calculateFlywheel(
			spokes,					// number of spokes
			flydia/2,				// radius of flywheel
			flydia/2 - rim,			// radius of rim
			hubdia/2,				// radius of hub
			shaftdia/2,				// radius of shaft
			inholedia/2,			// radius of inner cut hole
			inholeang,				// angle of inner cut hole
			inholedist,				// distance to center of inner hole
			outholedia/2,				// radius of outer cut hole
			outholeang,				// angle of outer cut hole
			outholedist);			// distance to center of outer hole
	
	//
	// Finally draw it, and draw it again with dimension markup.
	//
	var canvas = document.getElementById("flywheelDemoCanvas");
	drawFlywheelDemo(canvas, fly);
	var canvasdims = document.getElementById("flywheelDimsCanvas");
	drawFlywheelDemo(canvasdims, fly);
	drawFlywheelDims(canvasdims, fly);

	//
	// Now do a pile of document fixups to personalize the web page
	// instructions to the flywheel design
	//
	var RTrotate = document.getElementById("RTrotate");
	var RToffset = document.getElementById("RToffset");
	var si = fly.spkinfo[0];
	var cutangle = 360 - si.leftCutAngle;
	if (cutangle == 360)
		cutangle = 0;	// more sane
	var cuts = rotate(si.leftCutEdgeStart, cutangle);
	RTrotate.innerHTML = cutangle.toFixed(angdigits);
	RToffset.innerHTML = cuts.x.toFixed(lendigits);
	// More instruction customization:
	document.getElementById("instRTrotate").innerHTML = cutangle.toFixed(angdigits);
	document.getElementById("instRTrotateLeft").innerHTML = (360 - cutangle).toFixed(angdigits);
	document.getElementById("instRToffset").innerHTML = cuts.x.toFixed(lendigits);
	document.getElementById("instRToffsetBack").innerHTML = cuts.x.toFixed(lendigits);
	document.getElementById("instOuterArc").innerHTML = (fly.outerHoleDistance + fly.outerHoleRadius).toFixed(lendigits);
	document.getElementById("instOuterDist").innerHTML = fly.outerHoleDistance.toFixed(lendigits);
	document.getElementById("instOuterRadius").innerHTML = fly.outerHoleRadius.toFixed(lendigits);
	document.getElementById("instRTspokeAngle1").innerHTML = fly.spokedeg.toFixed(angdigits);
	document.getElementById("instRTspokeAngle2").innerHTML = fly.spokedeg.toFixed(angdigits);
	document.getElementById("instRTspokeAngle3").innerHTML = fly.spokedeg.toFixed(angdigits);

	var ThreeHoleAngle = document.getElementById("ThreeHoleAngle");
	var angle3hole = fly.spokedeg/2;
	ThreeHoleAngle.innerHTML = angle3hole.toFixed(angdigits);
	
	// Calculate thickness of spoke at inner and outer holes.
	// This is easy with spoke zero because Y is fixed.  That is, they
	// are horizontally aligned and also equidistant from the spoke.
	// So just use the X dimension less the radius of the hole and double it.
	var InnerThick = document.getElementById("InnerThick");
	var OuterThick = document.getElementById("OuterThick");
	var innerSpokeThickness = (si.leftInnerCenter.x - fly.innerHoleRadius)*2;
	var outerSpokeThickness = (si.leftOuterCenter.x - fly.outerHoleRadius)*2;
	InnerThick.innerHTML = innerSpokeThickness.toFixed(lendigits);
	OuterThick.innerHTML = outerSpokeThickness.toFixed(lendigits);
	
	//
	// Now update cutting schedule tables.
	// Each has a single row heading, so we delete the extra rows
	// and generate new ones.  Table row indexes start at 0 (the heading).
	//
	var table;
	
	// The spokeTable.  This is just a list of the primary spoke
	// angles and is more of a reference than anything.
	table = document.getElementById("spokeTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	for (var spk=0; spk < spokes; spk++) {
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang = row.insertCell(1);
		spkcell.innerHTML = spk+1;   // number from 1
		spkang.innerHTML = fly.spkinfo[spk].angle.toFixed(angdigits);
	}
	
	// The inner hole cutout table.  If the left/right inner holes are
	// identical (typical -- 3 hole cutout), then we show only one reading
	// per spoke, of course.
	table = document.getElementById("innerHoleTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	for (var spk=0; spk < spokes; spk++) {
		// Always insert the left hole.
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang = row.insertCell(1);
		spkcell.innerHTML = spk+1;   // number from 1
		spkang.innerHTML = fly.spkinfo[spk].leftInnerAngle.toFixed(angdigits);
		if (fly.spkinfo[spk].rightInnerAngle !=
			fly.spkinfo[spk].leftInnerAngle) {
			// show right angle also.  Don't include the spoke # (blank)
			spkang = row.insertCell(2);
			spkang.innerHTML = fly.spkinfo[spk].rightInnerAngle.toFixed(angdigits);
		}
	}
	// Update the message under the table with actual dimensions.
	document.getElementById("inTabDia").innerHTML = (fly.innerHoleRadius*2).toFixed(lendigits);
	document.getElementById("inTabDist").innerHTML = fly.innerHoleDistance.toFixed(lendigits);
	if (fly.spkinfo[0].rightInnerAngle == fly.spkinfo[0].leftInnerAngle) {
			document.getElementById("inTab4holeMsg").innerHTML =
			"This is a 3-hole web cutout, so there is only one hole to " +
			"drill on the clockwise side of each spoke.  " + 
			"The angle is listed for each spoke.";
			document.getElementById("instFinish4WebMsg").innerHTML =
			"This is a 3-hole web cutout, so only the outer arc of the web" +
			" needs to be cut for each web.";
	} else {
			document.getElementById("inTab4holeMsg").innerHTML =
			"This is a 4-hole web cutout, so there are two holes to drill " +
			"on the clockwise side of each spoke.  The angles are listed. " +
			"It is less error prone to drill the left hole for each " +
			"spoke first, and then go around again drilling the right.";
			document.getElementById("instFinish4WebMsg").innerHTML =
			"This is a 4-hole web cutout, so the inner arc of the web" +
			" needs to be cut.  Return the RT so that it and the flywheel" +
			" are centered under the mill.  The inner arc is at " +
			(fly.innerHoleDistance - fly.innerHoleRadius).toFixed(lendigits) +
			".  This is the inner hole center distance of " +
			fly.innerHoleDistance.toFixed(lendigits) +
			" less the radius of the inner hole which is " + 
			fly.innerHoleRadius.toFixed(lendigits) +
			".  Offset X (or Y) by this amount as well as an additional" +
			" distance to account for the end mill radius.  Make the cut" +
			" for each web being very careful NOT to cut through a spoke!";
	}
	
	// The outer hole cutout table.  
	table = document.getElementById("outerHoleTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	for (var spk=0; spk < spokes; spk++) {
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang1 = row.insertCell(1);
		var spkang2 = row.insertCell(2);

		spkcell.innerHTML = spk+1;   // number from 1
		spkang1.innerHTML = fly.spkinfo[spk].leftOuterAngle.toFixed(angdigits);
		spkang2.innerHTML = fly.spkinfo[spk].rightOuterAngle.toFixed(angdigits);
	}
	// Update the message under the table with actual dimensions.
	document.getElementById("outTabDia").innerHTML = (fly.outerHoleRadius*2).toFixed(lendigits);
	document.getElementById("outTabDist").innerHTML = fly.outerHoleDistance.toFixed(lendigits);
	
	// Now fill in the instSpokeStep*Canvas figures
	drawSpokeStep(1, document.getElementById("instSpokeStep1Canvas"), fly);
	drawSpokeStep(2, document.getElementById("instSpokeStep2Canvas"), fly);
	drawSpokeStep(3, document.getElementById("instSpokeStep3Canvas"), fly);
	drawSpokeStep(4, document.getElementById("instSpokeStep4Canvas"), fly);

	// Now update the # (hash) so the URL matches the inputs
	// Thus, it can be bookmarked with the current settings.
	location.hash = genhash();
}


/*
 * Utility math functions.
 *
 * What follow are a bunch of utility functions for simple conversions
 * and calculations.  They exist partly for convenience, and partly because
 * this code wants to do the flywheel math using a coordinate system more
 * convenient for the purpose.
 *
 * Canvas coordinates for drawing are specified with 0,0 as the upper right
 * corner and X increasing to the right, and Y increasing down.  Thus, all
 * coordinates are positive.   For the flywheel it is more convenient to place
 * 0,0 at the shaft center with Y increasing up, negative Y down, X increasing
 * right, and negative X left.
 *
 * Angles here are in degrees (canvas uses radians) where 0 is up and positive
 * angles increase clockwise.  Negative angles therefore go counter-clockwise.
 */

// Angle conversions.
function radiansToDegrees(r) {
	return r * (180/Math.PI);
}
function degreesToRadians(d) {
	return d * (Math.PI/180);
}

// Many functions want a point.  Trivially construct a point object.
// Methods could be defined, but for now functions (below) are used.
function toPoint(x, y)
{
	return { x: x, y: y};
}

// Add two points returning one that is a sum.
function addPoints(p1, p2)
{
	return toPoint(p1.x + p2.x, p1.y + p2.y);
}
// Subtract p1 from p2 producing a delta point
function subtractPoints(p1, p2)
{
	return toPoint(p2.x - p1.x, p2.y - p1.y);
}
// Return a scaled point multipled by the scaling factor
function scalePoint(p, multiplier)
{
	return toPoint(p.x * multiplier, p.y * multiplier);
}

// Distance between two points.
function distance(p1, p2) {
	var dp = subtractPoints(p1, p2);
	return Math.sqrt(dp.x*dp.x + dp.y*dp.y);
}

// Calculate angle between two points.
// See general description above for the orientation
function angle(p1, p2) {
	var dp = subtractPoints(p1, p2);
	var ang = radiansToDegrees(Math.atan2(dp.x, dp.y));
	if (ang < 0)
		ang += 360;		// Use a 0..360 scale, rather than -180..180
	return ang;
}

// Return a rotated point when the axes are rotated clockwise.
function rotate(p, angleDeg) {
	var angle = degreesToRadians(-angleDeg);
	var sinAng = Math.sin(angle);
	var cosAng = Math.cos(angle);
	return toPoint(p.x * cosAng - p.y * sinAng, p.x * sinAng + p.y * cosAng);
}

/*
 * Utility drawing functions
 *
 * These replace a lot of boilerplate drawing work.
 * These functions draw in the canvas coordinate system.
 *
 * Patterns aren't implemented in IE10 and earlier.  They could probably
 * be changed to undefined and it work work with solid lines for everything.
 */

// Define some line patterns.
// These are defined by canvas as pairs of integers.  Pixels on/off.
var pattern_solid = undefined;		// default is solid, so use undefined
var pattern_dot = [2, 4];	// dot, dot-space
var pattern_dash_dot_dot = [5, 5, 2, 3, 2, 3];  // dash, dash-space, ...

// Fill
// No fill uses undefined as that is the default
// I could define some standard fills here, but I use color names for now
var fill_none = undefined;

// Draw a line with color and pattern
function drawLine(context, x1, y1, x2, y2, color, pattern)
{
	context.save();
	if (color)
		context.strokeStyle = color;
	if (pattern && context.setLineDash)
		context.setLineDash(pattern);
	context.beginPath();
	context.moveTo(x1, y1);
	context.lineTo(x2, y2);
	context.stroke();
	context.restore();
}

// Draw a radial line at an angle from the given x,y starting point.
// The angle is in degrees and we interpret it as clockwise from
// straight up.  We could let the canvas do the rotation, but since
// we are doing so much trig anyway, just calculate it.
function drawRadialLine(context, x, y, angleDeg, length, color, pattern)
{
	context.save();
	if (color)
		context.strokeStyle = color;
	if (pattern && context.setLineDash)
		context.setLineDash(pattern);
	context.beginPath();
	context.moveTo(x,y);
	// rotate the endpoint of a vertical (x=0) line going up (y=length)
	var dest = rotate(toPoint(0, length), angleDeg);
	// subtract y to go up because canvas has 0,0 in the upper left
	context.lineTo(x+dest.x, y-dest.y);
	context.stroke();
	context.restore();
}

/* Same as drawRadialLine, except now drawing a dimension line.
 * This means adding arrowheads and a dimension label.
 * The labelpos is the % of the way from start to end for the
 * center of the label.
 */
function drawRadialDim(context,
		x, y, angleDeg,
		startlen, length,
		label, labelpos,
		color, pattern)
{
	context.save();
	if (color)
		context.strokeStyle = color;
	if (pattern && context.setLineDash)
		context.setLineDash(pattern);
	
	// We will draw a "horizontal" line and let canvas do the rotating for us.
	// We use horizontal because that is how text is drawn.  This makes it a bit
	// more complicated because we must interpret angleDeg=0 as "up".
	// Since we want horizontal, we'll just subtract 90 degrees.
	context.translate(x,y);		// Now 0,0 is the center.
	context.rotate((angleDeg-90)*Math.PI/180);

	context.beginPath();
	context.moveTo(startlen,0);
	context.lineTo(length, 0);
	// draw end arrowhead since we are here
	context.lineTo(length-5, -3);
	context.moveTo(length, 0);
	context.lineTo(length-5, 3);
	// draw start arrowhead
	context.moveTo(startlen,0);
	context.lineTo(startlen+5, -3);
	context.moveTo(startlen,0);
	context.lineTo(startlen+5, 3);
	// Now draw the label in the middle
	var textwidth = context.measureText(label).width;
	context.fillStyle = color;
	context.fillText(label, startlen+((length-startlen)*labelpos)-(textwidth/2), -3);
	context.stroke();
	context.restore();
}

/* This draws an angle dimension line.
 *
 * x,y			Center point of angle
 * start, end	Start/end of angle in degrees with 0 as up.
 * length		Length of dimension lines
 * label		The label to draw.  Probably end - start :)
 * labelpos		The percentage up the dimension lines to draw the
 *				dimension arc and label.
 * context, color and pattern define drawing context to use.
 */
function drawAngDim(context,
		x, y, start, end,
		length,
		label, labelpos,
		color, pattern)
{
	var srad = degreesToRadians(start-90);
	var erad = degreesToRadians(end-90);
	var sdim = rotate(toPoint(0, length), start);
	var edim = rotate(toPoint(0, length), end);

	context.save();
	if (color)
		context.strokeStyle = color;
	if (pattern && context.setLineDash)
		context.setLineDash(pattern);
	context.beginPath();
	// Draw dimension lines first.
	context.moveTo(x,y);
	context.lineTo(x+sdim.x, y-sdim.y);
	context.moveTo(x,y);
	context.lineTo(x+edim.x, y-edim.y);
	context.stroke();
	context.beginPath();
	context.arc(x,y,length*labelpos,srad,erad);
	context.stroke();

	// Now draw the label.  We center this on the arc and want it rotated to
	// match the arc.  Let the canvas do the rotation.  Remember up is 0 deg
	// so I need to subtract 90 to get that.  HOWEVER, we want the text 90
	// degrees from the angle anyway, so it works out without this!  Sweet.
	context.translate(x,y);		// Now 0,0 is the center.
	context.rotate((start+end)/2*Math.PI/180);
	context.fillStyle = color;
	var textwidth = context.measureText(label).width;
	var textheight = context.measureText(label).height;
	context.fillText(label, -textwidth/2, -length*labelpos-5);

	context.restore();
}

// Draw a circle
// Nothing exciting here, except we use the given color, fill, and pattern.
function drawCircle(context, x, y, radius, color, fill, pattern)
{
	context.save();
	if (color)
		context.strokeStyle = color;
	if (pattern && context.setLineDash)
		context.setLineDash(pattern);
	context.beginPath();
	context.arc(x,y,radius,0,2*Math.PI);
	if (fill) {
		context.fillStyle = fill;
		context.fill();
	}
	context.stroke();
	context.restore();
}

// Draw an arc
// The start/end angles are in degrees where 0 is straight up (adjusted here).
// We use the given color and pattern.
function drawArc(context, x, y, radius, start, end, color, pattern)
{
	var srad = degreesToRadians(start-90);
	var erad = degreesToRadians(end-90);
	context.save();
	if (color)
		context.strokeStyle = color;
	if (pattern && context.setLineDash)
		context.setLineDash(pattern);
	context.beginPath();
	context.arc(x,y,radius,srad,erad);
	context.stroke();
	context.restore();
}


/* Calculate Flywheel data
 * =======================
 *
 * This function doesn't draw anything.  It calculates all the useful
 * coordinates and angles for the flywheel.
 *
 * The input arguments are documented in the function declaration.  These
 * come from the web page user interface.  Angles are specified here in
 * degrees.  Length units are unspecified, but are assumed to be consistant
 * (i.e. use all inches or mm for lengths)
 *
 * The outputs are documented at the end of the function where an object
 * containing all this data is returned.
 *
 * Note that the coordinate system for these calculations is what you'd use
 * in a math graph.  That is, 0,0 is the center of the flywheel.  The first
 * spoke will be created straight up, and angles in the output will be measured
 * in a clockwise direction, in degrees, from this vertical spoke.
 *
 * Note also that some internal calculations within this function use a
 * rotated and transformed (shifted) coordinate system.  I'll try to document
 * this so it can be understood.
 */
function calculateFlywheel(
	spokes,				// 2..something reasonable.
	flywheelRadius,		// outside of flywheel in units (mm, inches, etc)
	rimRadius,			// inside of flywheel rim
	hubRadius,			// outside of hub
	shaftRadius,		// shaft size (note: radius, not diameter)
	innerHoleRadius,	// hole size used in the web near the shaft
	innerHoleAngle,		// angle of inner hole clockwise from vertical
	innerHoleDistance,	// radius of inner hole from the center
	outerHoleRadius,	// hole size used in the web near the rim
	outerHoleAngle,		// angle of outer hole clockwise from vertical
	outerHoleDistance	// radius of outer hole from the center
) {

	// Return an object with a pile of fields, including the inputs
	var fly = {
		spokes: spokes,
		spokedeg: 360 / spokes,
		flywheelRadius: flywheelRadius,
		rimRadius: rimRadius,
		hubRadius: hubRadius,
		shaftRadius: shaftRadius,
		innerHoleRadius: innerHoleRadius,
		innerHoleDistance: innerHoleDistance,
		outerHoleRadius: outerHoleRadius,
		outerHoleDistance: outerHoleDistance,
		spkinfo: []		// Array of info per spoke filled in below.
	};
	

	// Fill in spkinfo
	// Inner and outer circle center coords go here.
	var spk;
	var spkangle = 0;
	for (spk = 0; spk < spokes; spk++) {
		var si = {};	// spoke info object
		fly.spkinfo[spk] = si;  // remember it, but use si as a shortcut
		
		// Assign this spoke's angle (relate to vertical which is 0).
		si.angle = spkangle;
		
		// Calculate angles and coords of the 4 holes
		var inpoint = toPoint(0,innerHoleDistance);
		var outpoint = toPoint(0,outerHoleDistance);
		si.leftInnerAngle = si.angle + innerHoleAngle;
		si.leftInnerCenter = rotate(inpoint, si.leftInnerAngle);
		si.leftOuterAngle = si.angle + outerHoleAngle;
		si.leftOuterCenter = rotate(outpoint, si.leftOuterAngle);
		si.rightInnerAngle = si.angle + fly.spokedeg - innerHoleAngle;
		si.rightInnerCenter = rotate(inpoint, si.rightInnerAngle);
		si.rightOuterAngle = si.angle + fly.spokedeg - outerHoleAngle;
		si.rightOuterCenter = rotate(outpoint, si.rightOuterAngle);
		
		// Calculate the finished edge outer arc.
		si.edgeOuterArc = {};  // new object.
		si.edgeOuterArc.radius = outerHoleDistance + outerHoleRadius;
		si.edgeOuterArc.startAngle = si.leftOuterAngle;
		si.edgeOuterArc.endAngle = si.rightOuterAngle;
		// Calculate the finished edge inner arc.
		si.edgeInnerArc = {};  // new object.
		si.edgeInnerArc.radius = innerHoleDistance - innerHoleRadius;
		si.edgeInnerArc.startAngle = si.leftInnerAngle;
		si.edgeInnerArc.endAngle = si.rightInnerAngle;
		
		// Now the tricky bits.  Calculate the left and right cut lines.
		// We'll produce x,y start/end points as well as length and angle.
		// First calc the angles between the center points of inner/outer holes.
		var leftHoleCenterAngle = angle(si.leftInnerCenter, si.leftOuterCenter);
		var leftHoleDistance = distance(si.leftInnerCenter,	si.leftOuterCenter);
		var rightHoleCenterAngle = angle(si.rightInnerCenter, si.rightOuterCenter);
		var rightHoleDistance = distance(si.rightInnerCenter, si.rightOuterCenter);

		// Next we need to work with the coords and angle formed because the
		// inner/outer holes might be different diameter.  Let's temporarily
		// do calculations with a Y axis straight through the center points
		// of the inner/outer holes where Y=0 is the center of the inner hole.
		var leftStart = rotate(toPoint(-fly.innerHoleRadius, 0), leftHoleCenterAngle);
		var leftEnd = rotate(toPoint(-fly.outerHoleRadius, leftHoleDistance), leftHoleCenterAngle);
		var rightStart = rotate(toPoint(fly.innerHoleRadius, 0), rightHoleCenterAngle);
		var rightEnd = rotate(toPoint(fly.outerHoleRadius, rightHoleDistance), rightHoleCenterAngle);
		
		// The positions are currently relative to 0,0 in those
		// calculations which was the center of the inner hole.  Adjust.
		si.leftCutEdgeStart = addPoints(si.leftInnerCenter, leftStart);
		si.leftCutEdgeEnd = addPoints(si.leftInnerCenter, leftEnd);
		si.leftCutAngle = angle(si.leftCutEdgeStart, si.leftCutEdgeEnd);
		si.rightCutEdgeStart = addPoints(si.rightInnerCenter, rightStart);
		si.rightCutEdgeEnd = addPoints(si.rightInnerCenter, rightEnd);
		si.rightCutAngle = angle(si.rightCutEdgeStart, si.rightCutEdgeEnd);

		// Lock the angles in to rounded numbers
		si.leftCutAngle = si.leftCutAngle.toFixed(angdigits);
		si.rightCutAngle = si.rightCutAngle.toFixed(angdigits);

		/*
		console.log("centers (" + si.leftInnerCenter.x + "," + si.leftInnerCenter.y + ") to (" + si.leftOuterCenter.x + "," + si.leftOuterCenter.y + ")");
		console.log("angle=" + si.leftCutAngle + " cutline (" + si.leftCutEdgeStart.x + "," + si.leftCutEdgeStart.y + ") to (" + si.leftCutEdgeEnd.x + "," + si.leftCutEdgeEnd.y + ")");
		console.log("inner distance=" + distance(si.leftCutEdgeStart, si.leftInnerCenter) + "  outer distance=" + distance(si.leftCutEdgeEnd, si.leftOuterCenter));
		*/

		// Now calculate 4 drawing arcs for the remaining edges of the
		// holes that were drilled.  These aren't useful on the mill, but
		// are useful when drawing the flywheel.  We already have recorded
		// the arc centers and radii as center/radius of each hole, so all
		// we need to record now is the start/end angles of each arc.
		// (Note:  I'm cheating in calculations here a little, not accounting
		// for the angle caused by the differing hole sizes)
		si.leftOuterHoleArc = {};
		si.leftOuterHoleArc.startAngle = leftHoleCenterAngle - 90;
		si.leftOuterHoleArc.endAngle = si.leftOuterAngle;
		si.leftInnerHoleArc = {};
		si.leftInnerHoleArc.startAngle = si.leftInnerAngle - 180;
		si.leftInnerHoleArc.endAngle = leftHoleCenterAngle - 90 - 360;
		si.rightOuterHoleArc = {};
		si.rightOuterHoleArc.startAngle = si.rightOuterAngle;
		si.rightOuterHoleArc.endAngle = rightHoleCenterAngle - 270;
		si.rightInnerHoleArc = {};
		si.rightInnerHoleArc.startAngle = rightHoleCenterAngle + 90;
		si.rightInnerHoleArc.endAngle = si.rightInnerAngle - 180;
		
		// advance to next angle
		spkangle += fly.spokedeg;
	}

	return fly;
}

/* Draw the Flywheel.
 *
 */
function drawFlywheelDemo(canvas, fly) {

	/* Now calculate offsets and a scaling factor so we can draw the
	 * flywheel the middle of the canvas.  We scale it to 90% of the space
	 * so that dimension lines can extend beyond the diameter.
	 */
	var context = canvas.getContext("2d");
	var offsetx = canvas.width / 2;
	var offsety = canvas.height / 2;
	var fscale = Math.min(canvas.width, canvas.height) * 0.90 /
					(fly.flywheelRadius * 2);

	// Assigning to canvas.width will clear it
	canvas.width = canvas.width;

	// Draw the flywheel
	//
	// Shade the flywheel light gray, but fill in the web (out to the rim)
	// with a white circle.  The hub is also white, but the shaft is dark gray.
	drawCircle(context, offsetx, offsety, fly.flywheelRadius*fscale,
				"black", "lightgray", pattern_solid);
	drawCircle(context, offsetx, offsety, fly.rimRadius*fscale,
				"black", "white", pattern_solid);
	drawCircle(context, offsetx, offsety, fly.hubRadius*fscale,
				"black", "white", pattern_solid);
	drawCircle(context, offsetx, offsety, fly.shaftRadius*fscale,
				"black", "gray", pattern_solid);
	
	// Draw the radius lines for inner/outer hole pattern
	drawCircle(context, offsetx, offsety, fly.innerHoleDistance*fscale,
				"red", fill_none, pattern_dot);
	drawCircle(context, offsetx, offsety, fly.outerHoleDistance*fscale,
				"red", fill_none, pattern_dot);

	// Loop through the spokes and draw stuff using the spkinfo.
	// Note that the info for spoke position N refers to detail clockwise
	// from the spoke.  Position N=0 is straight up.
	var spk;
	for (spk in fly.spkinfo) {
		var si = fly.spkinfo[spk];
		drawRadialLine(context, offsetx, offsety, si.angle,
				fly.flywheelRadius*fscale*1.05,   		// scale up 10%
				"black", pattern_dash_dot_dot);
		// Draw the 4 holes
		drawCircle(context,
					offsetx + si.leftInnerCenter.x*fscale,
					offsety - si.leftInnerCenter.y*fscale, // Y goes down in canvas
					fly.innerHoleRadius*fscale,
					"lightgray", fill_none, pattern_solid);
		drawCircle(context,
					offsetx + si.rightInnerCenter.x*fscale,
					offsety - si.rightInnerCenter.y*fscale, // Y goes down in canvas
					fly.innerHoleRadius*fscale,
					"lightgray", fill_none, pattern_solid);
		drawCircle(context,
					offsetx + si.leftOuterCenter.x*fscale,
					offsety - si.leftOuterCenter.y*fscale, // Y goes down in canvas
					fly.outerHoleRadius*fscale,
					"lightgray", fill_none, pattern_solid);
		drawCircle(context,
					offsetx + si.rightOuterCenter.x*fscale,
					offsety - si.rightOuterCenter.y*fscale, // Y goes down in canvas
					fly.outerHoleRadius*fscale,
					"lightgray", fill_none, pattern_solid);
		// Draw the outer edge arc
		drawArc(context, offsetx, offsety,
					si.edgeOuterArc.radius*fscale,
					si.edgeOuterArc.startAngle,
					si.edgeOuterArc.endAngle,
					"black", pattern_solid);
		// Draw the inner edge arc
		drawArc(context, offsetx, offsety,
					si.edgeInnerArc.radius*fscale,
					si.edgeInnerArc.startAngle,
					si.edgeInnerArc.endAngle,
					"black", pattern_solid);
		// Draw left/right cut lines
		drawLine(context,
				offsetx+si.leftCutEdgeStart.x*fscale,
				offsety-si.leftCutEdgeStart.y*fscale,  // Y goes down
				offsetx+si.leftCutEdgeEnd.x*fscale,
				offsety-si.leftCutEdgeEnd.y*fscale,		// Y goes down
				"black", pattern_solid);
		drawLine(context,
				offsetx+si.rightCutEdgeStart.x*fscale,
				offsety-si.rightCutEdgeStart.y*fscale,  // Y goes down
				offsetx+si.rightCutEdgeEnd.x*fscale,
				offsety-si.rightCutEdgeEnd.y*fscale,		// Y goes down
				"black", pattern_solid);
		// Draw arcs to connect cut lines with cut edge arcs
		drawArc(context,
				offsetx + si.leftOuterCenter.x*fscale,
				offsety - si.leftOuterCenter.y*fscale, // Y goes down in canvas
				fly.outerHoleRadius*fscale,
				si.leftOuterHoleArc.startAngle,
				si.leftOuterHoleArc.endAngle,
				"black", pattern_solid);
		drawArc(context,
				offsetx + si.leftInnerCenter.x*fscale,
				offsety - si.leftInnerCenter.y*fscale, // Y goes down in canvas
				fly.innerHoleRadius*fscale,
				si.leftInnerHoleArc.startAngle,
				si.leftInnerHoleArc.endAngle,
				"black", pattern_solid);
		drawArc(context,
				offsetx + si.rightOuterCenter.x*fscale,
				offsety - si.rightOuterCenter.y*fscale, // Y goes down in canvas
				fly.outerHoleRadius*fscale,
				si.rightOuterHoleArc.startAngle,
				si.rightOuterHoleArc.endAngle,
				"black", pattern_solid);
		drawArc(context,
				offsetx + si.rightInnerCenter.x*fscale,
				offsety - si.rightInnerCenter.y*fscale, // Y goes down in canvas
				fly.innerHoleRadius*fscale,
				si.rightInnerHoleArc.startAngle,
				si.rightInnerHoleArc.endAngle,
				"black", pattern_solid);


	}
}

/* Draw the Flywheel dimension markings.
 *
 */
function drawFlywheelDims(canvas, fly) {

	/* Now calculate offsets and a scaling factor so we can draw the
	 * flywheel the middle of the canvas.  We scale it to 90% of the space
	 * so that dimension lines can extend beyond the diameter.
	 */
	var context = canvas.getContext("2d");
	var offsetx = canvas.width / 2;
	var offsety = canvas.height / 2;
	var fradius =  Math.min(canvas.width, canvas.height) * 0.90 / 2;
	var fscale = fradius / fly.flywheelRadius;
	var si0 = fly.spkinfo[0];
					
	/* First, dim the flywheel by drawing a transparent white rectangle over it.  Cool, no? :) */
	context.save();
	context.fillStyle="white";
	context.globalAlpha="0.65";
	context.fillRect(0,0,canvas.width,canvas.height);
	context.restore();
	
	// Draw the web cutout holes.
	// There can be 4 holes, but usually the inner holes are aligned so
	// there are really only 3 holes.  We draw all 4 here because it makes
	// little difference to draw the same inner circle twice.
	drawCircle(context,
				offsetx + si0.leftInnerCenter.x*fscale,
				offsety - si0.leftInnerCenter.y*fscale, // Y goes down in canvas
				fly.innerHoleRadius*fscale,
				"black", fill_none, pattern_solid);
	drawCircle(context,
				offsetx + si0.rightInnerCenter.x*fscale,
				offsety - si0.rightInnerCenter.y*fscale, // Y goes down in canvas
				fly.innerHoleRadius*fscale,
				"black", fill_none, pattern_solid);
	drawCircle(context,
				offsetx + si0.leftOuterCenter.x*fscale,
				offsety - si0.leftOuterCenter.y*fscale, // Y goes down in canvas
				fly.outerHoleRadius*fscale,
				"black", fill_none, pattern_solid);
	drawCircle(context,
				offsetx + si0.rightOuterCenter.x*fscale,
				offsety - si0.rightOuterCenter.y*fscale, // Y goes down in canvas
				fly.outerHoleRadius*fscale,
				"black", fill_none, pattern_solid);
	// Redraw the hole distance lines in black, but keep them dotted
	drawCircle(context, offsetx, offsety, fly.innerHoleDistance*fscale,
				"black", fill_none, pattern_dot);
	drawCircle(context, offsetx, offsety, fly.outerHoleDistance*fscale,
				"black", fill_none, pattern_dot);


	// Radial dimensions from the center of the flywheel.
	// These are offset from the spokedeg to get them out of the way of the
	// detail dimensions for cutting the webs.
	
	// Inner hole distance
	drawRadialDim(context, offsetx, offsety, fly.spokedeg + 10,
			0, fly.innerHoleDistance*fscale,
			fly.innerHoleDistance.toFixed(lendigits), 0.75,
			"black", pattern_solid);
	
	// Outer hole distance
	drawRadialDim(context, offsetx, offsety, fly.spokedeg + 22.5,
			0, fly.outerHoleDistance*fscale,
			fly.outerHoleDistance.toFixed(lendigits), 0.75,
			"black", pattern_solid);
	
	// Rim radius
	drawRadialDim(context, offsetx, offsety, fly.spokedeg + 32.5,
			0, fly.rimRadius*fscale,
			fly.rimRadius.toFixed(lendigits), 0.75,
			"black", pattern_solid);
	// Rim thickness
	var rim = fly.flywheelRadius - fly.rimRadius;
	drawRadialDim(context, offsetx, offsety, fly.spokedeg + 28,
			fly.rimRadius*fscale, fly.flywheelRadius*fscale,
			rim.toFixed(lendigits), 0.50,
			"black", pattern_solid);

	// Flywheel Radius dimension (do we need diameter?)
	drawRadialDim(context, offsetx, offsety, fly.spokedeg + 40,
			0, fly.flywheelRadius*fscale,
			fly.flywheelRadius.toFixed(lendigits), 0.70,
			"black", pattern_solid);
	
	// Hub Radius dimension is only useful as feedback from settings.
	// I place it as the last dimension and push out the label since I
	// know space is always going to be tight for the dimension to fit.
	drawRadialDim(context, offsetx, offsety, fly.spokedeg + 75,
			0, fly.hubRadius*fscale,
			fly.hubRadius.toFixed(lendigits), 0.80,
			"black", pattern_solid);

	// Outer hole angle.  Draw this in the first web cutout.
	drawAngDim(context,
		offsetx, offsety, 0, si0.leftOuterAngle,
		fradius * 0.88,
		si0.leftOuterAngle.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);
	
	if (si0.rightOuterAngle > si0.leftOuterAngle) {  // should always be true
		drawAngDim(context,
			offsetx, offsety, 0, si0.rightOuterAngle,
			fradius * 0.95,
			si0.rightOuterAngle.toFixed(angdigits) + DEGSYM, 0.98,
			"black", pattern_solid);
	}
	
	// Inner hole angle.  Draw this in the first web cutout.
	drawAngDim(context,
		offsetx, offsety, 0, si0.leftInnerAngle,
		fradius * 0.50,
		si0.leftInnerAngle.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);
	
	if (si0.rightInnerAngle > si0.leftInnerAngle) {
		// Second Inner hole angle.  Draw this in the first web cutout.
		drawAngDim(context,
			offsetx, offsety, 0, si0.rightInnerAngle,
			fradius * 0.57,
			si0.rightInnerAngle.toFixed(angdigits) + DEGSYM, 0.98,
			"black", pattern_solid);
	}	


	// Flywheel spoke angle.  Draw this in the last web cutout.
	drawAngDim(context,
		offsetx, offsety, -fly.spokedeg, 0,
		fradius * 0.91,
		fly.spokedeg.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);

	// Add degree marks for each spoke.  Get this out of spkinfo
	// even though it's easy to calculate.
	context.save();
	var spk;
	for (spk=0; spk < fly.spokes; spk++) {
		var si = fly.spkinfo[spk];
		var label = si.angle.toFixed(angdigits) + DEGSYM;
		var textwidth = context.measureText(label).width;
		var dest = rotate(toPoint(0, fradius * 1.07), si.angle);
		context.fillText(label, offsetx+dest.x - textwidth/2, offsety-dest.y);
	}
	context.restore();

}

//
// Draw the Step N figure for the spoke cutting setup.
//
// We draw a very simplified flywheel for this.  The main idea is to show
// what the setup movements are to avoid any chance of confusion.
//
// Step one shows the initial setup.  We have the flywheel centered with
// spoke 1 "up".  It shows the inner/outer holes and the cut line we are
// trying to establish.
//
function drawSpokeStep(step, canvas, fly) {

	/* Now calculate offsets and a scaling factor so we can draw the
	 * flywheel the middle of the canvas.  We scale it to 90% of the space
	 * so that dimension lines can extend beyond the diameter.
	 */
	var context = canvas.getContext("2d");
	var offsetx = canvas.width / 2;
	var offsety = canvas.height / 2;
	var fradius =  Math.min(canvas.width, canvas.height) * 0.90 / 2;
	var fscale = fradius / fly.flywheelRadius;
	var si0 = fly.spkinfo[0];	// Use spoke 1 (index 0) for example steps
	var cutangle = 0;
	var cutshift = 0;
	
	if (step > 1) {
		cutangle = 360-si0.leftCutAngle;
		if (cutangle == 360)
			cutangle = 0;	// more sane
	}
	
	if (step > 2) {
		// Calculate cut shift (cuts.x)
		var cuts = rotate(si0.leftCutEdgeStart, cutangle);
		cutshift = cuts.x;
	}
	
	if (step > 3) {
		// Further shift to show endmill radius adjustment
		cutshift += 3/fscale;
	}
	
	// Assigning to canvas.width will clear it
	canvas.width = canvas.width;
	
	// Draw the circle representing the flywheel
	drawCircle(context, offsetx, offsety, fly.flywheelRadius*fscale,
				"black", "lightgray", pattern_solid);
	drawCircle(context, offsetx, offsety, fly.rimRadius*fscale,
				"black", "white", pattern_solid);
	drawCircle(context, offsetx, offsety, fly.hubRadius*fscale,
				"black", "white", pattern_solid);
	drawCircle(context, offsetx, offsety, fly.shaftRadius*fscale,
				"black", "gray", pattern_solid);
	
	// Draw the mill's cut line
	drawLine(context,
		offsetx+cutshift*fscale, 0, offsetx+cutshift*fscale, canvas.height,
		"blue", pattern_solid);
	context.save();
	// Draw a label saying it is the mill's cut line
	context.translate(offsetx+cutshift*fscale,offsety);	// Now 0,0 is the center.
	context.rotate(Math.PI/2);  // turn 90 degrees
	context.fillStyle = "blue";
	context.fillText("mill cut line", 20, -2);
	context.restore();

	// Draw the spoke 0 reference line
	drawRadialLine(context, offsetx, offsety, si0.angle + cutangle,
				fly.flywheelRadius*fscale*1.10,   		// scale up 10%
				"black", pattern_dash_dot_dot);

	// Draw the inner/outer holes.
	var inctr = rotate(si0.leftInnerCenter, cutangle);
	var outctr = rotate(si0.leftOuterCenter, cutangle);
	drawCircle(context,
				offsetx + inctr.x*fscale,
				offsety - inctr.y*fscale, // Y goes down in canvas
				fly.innerHoleRadius*fscale,
				"black", fill_none, pattern_solid);
	drawCircle(context,
				offsetx + outctr.x*fscale,
				offsety - outctr.y*fscale, // Y goes down in canvas
				fly.outerHoleRadius*fscale,
				"black", fill_none, pattern_solid);

	// Now draw the cut line in red
	// This has already been completely calculated in the spkinfo
	// but it needs rotation.
	var start = rotate(si0.leftCutEdgeStart, cutangle);
	var end = rotate(si0.leftCutEdgeEnd, cutangle);
	drawLine(context,
			offsetx + start.x*fscale,
			offsety - start.y*fscale,
			offsetx + end.x*fscale,
			offsety - end.y*fscale,
			"red", pattern_solid);

	//
	// Step-specific markings.
	//
	if (step == 2) {
			// Draw rotation arc arrow.  This is not to any scale.
			var endang = 45;
			var flip = 1;	// multiplier -- no flip
			if (cutangle > 180) {
				endang = 315;  // arc all the way around for emphasis
				flip = -1;	// used for flipping the sign for the arrow math
			}
			context.beginPath();
			context.arc(offsetx,offsety,fradius*1.07,-Math.PI/2.5,degreesToRadians(endang-90));
			// We end at 45 degrees.  Make a 45 degree arrowhead which is
			// easy because it is straight up/down and right/left
			end = rotate(toPoint(0,fradius*1.07), endang);
			context.moveTo(offsetx+end.x, offsety-end.y);
			context.lineTo(offsetx+end.x, offsety-end.y-5*flip);
			context.moveTo(offsetx+end.x, offsety-end.y);
			context.lineTo(offsetx+end.x-5, offsety-end.y);
			context.stroke();
	}
	if (step > 2) {
			// Draw shift arrow.  This is not to any scale.
			context.beginPath();
			context.moveTo(canvas.width-10, 20);
			context.lineTo(canvas.width-40, 20);
			context.lineTo(canvas.width-36, 16);
			context.moveTo(canvas.width-40, 20);
			context.lineTo(canvas.width-36, 24);
			context.stroke();
	}

}

</script>

</body>
</html>