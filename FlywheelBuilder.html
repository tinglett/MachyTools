<!DOCTYPE html>
<html>
<head>
<title>Flywheel Builder</title>
<!-- Copyright (C) 2015 Todd Inglett -->
<!-- License GPLv2.  See https://gnu.org/licenses/old-licenses/gpl-2.0.txt -->
<!--
For now, see the discussion at http://www.modelenginemaker.com/index.php/topic,5078.0.html
for some background and instructions on using this application.

This is fairly new and not well tested.  Double check everything and certainly
verify cuts look correct as you setup your mill.  Instructions for safely
using a mill and lathe are not covered here.  If you are just starting out,
try asking questions of all the fine and helpful people you will find at
http://www.modelenginemaker.com and you won't be disappointed!

Todd
 -->
<style>
table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
}
</style>
</head>

<body onLoad="buildFlywheels()">
<h2>Flywheel builder v1.5.3</h2>
<form name="flywheelParms" onChange="buildFlywheels()">
<!-- Use a select for spokes so crazy numbers (like fractions) can't happen -->
<canvas id="flywheelDemoCanvas" width="400" height="400"
  style="border:1px solid #d3d3d3;">
Your browser does not support the canvas element.  Sorry, this web page won't work for you.
</canvas>
<canvas id="flywheelDimsCanvas" width="400" height="400"
  style="border:1px solid #d3d3d3;">
</canvas>
<p><b>Dimensions:   </b>
Spokes: <select id="flywheelSpokes">
		<option value="3">3</option>
		<option value="4">4</option>
		<option value="5" selected>5</option>
		<option value="6">6</option>
		</select>
Units: <select id="flywheelUnits">
		<option value="mm">mm</option>
		<option value="in" selected>inches</option>
		</select>
Presets:  <select id="flywheelPresets" onchange="selectedPreset()">
		<option value="">Choose a Pre-designed Flywheel</option>
		<option value="spokes=6&units=in&dia=2.5&rim=0.25&hub=0.500&shaft=0.250&india=0.250&outdia=0.125&indis=0.438&outdis=0.875&inang=30.0&outang=8.2&curve=0">
		2.5" Diameter 6-spoke from Elmers #24 Beam</option>
		<option value="spokes=4&units=in&dia=3.0&rim=0.375&hub=0.625&shaft=0.250&india=0.250&outdia=0.250&indis=0.438&outdis=1.000&inang=32.0&outang=12.0&curve=0">
		3" Diameter 4-spoke Simple</option>
		<option value="spokes=6&units=in&dia=3.0&rim=0.375&hub=0.500&shaft=0.250&india=0.188&outdia=0.125&indis=0.438&outdis=1.000&inang=30.0&outang=9.0&curve=0">
		3" Diameter 6-spoke from Elmer's #5 Geared</option>
		<option value="spokes=5&units=in&dia=4.0&rim=0.312&hub=0.625&shaft=0.313&india=0.375&outdia=0.188&indis=0.625&outdis=1.438&inang=36.0&outang=8.0&curve=0">
		4" Diameter 5-spoke Thick</option>
		<option value="spokes=5&units=in&dia=4.0&rim=0.188&hub=0.625&shaft=0.313&india=0.375&outdia=0.188&indis=0.625&outdis=1.625&inang=36.0&outang=8.0&curve=0">
		4" Diameter 5-spoke Thin</option>
		<option value="spokes=6&units=in&dia=5.0&rim=0.094&hub=0.875&shaft=0.375&india=0.625&outdia=0.188&indis=0.875&outdis=2.125&inang=30.0&outang=6.0&curve=0">
		5.0" 6-spoke Easton &amp; Anderson Grasshopper</option>
		<option value="spokes=6&units=in&dia=6.5&rim=0.250&hub=0.625&shaft=0.313&india=0.25&outdia=0.188&indis=0.625&outdis=2.75&inang=24&outang=4.6&curve=0">
		6.5" Diameter 6-spoke Thin</option>

		</select>
		
<input id="prevFlywheelSpokes" value="0" hidden>
<input id="prevFlywheelUnits" value="none" hidden>
<input id="urlhash" value="" hidden>

<table style="text-align: left">
<tr><td>Flywheel diameter </td> <td><input id="flywheelDiameter" type="text" value="4.000" size="4" maxlength="8"></td>
    <td>Rim Thickness </td> <td><input id="flywheelRimThick" type="text" value="0.312" size="4" maxlength="8"></td></tr>
<tr><td>Hub diameter     </td> <td><input id="flywheelHubDiameter" type="text" value="0.625" size="4" maxlength="8"></td>
    <td>Shaft diameter   </td> <td><input id="flywheelShaftDiameter" type="text" value="0.313" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole diameter</td> <td><input id="flywheelInnerHoleDiameter" type="text" value="0.375" size="4" maxlength="8"></td>
    <td>Outer hole diameter</td> <td><input id="flywheelOuterHoleDiameter" type="text" value="0.188" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole distance</td> <td><input id="flywheelInnerHoleDistance" type="text" value="0.625" size="4" maxlength="8"></td>
    <td>Outer hole distance</td> <td><input id="flywheelOuterHoleDistance" type="text" value="1.438" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole angle</td> <td><input id="flywheelInnerHoleAngle" type="text" value="36.0" size="4" maxlength="8"></td>
    <td>Outer hole angle</td> <td><input id="flywheelOuterHoleAngle" type="text" value="8.0" size="4" maxlength="8"></td></tr>
</table>
<br>
Curve Angle: <input id="flywheelCurveAngle" type="text" value="0" size="3" maxlength="8">
</form>

<p>
The inner spoke thickness is <b id="InnerThick">0</b> and the outer spoke
thickness is <b id="OuterThick">0</b>.  Use an inner hole angle of <b id="ThreeHoleAngle"></b> to have a 3-hole web cutout.
<p>
The rotary table must be rotated <b id="RTrotate">0</b> degrees clockwise to bring the
spoke edge parallel to the mill axis.  The table must be offset by
x=<b id="RToffset">0</b> plus half the cutter diameter.  See the step-by-step
instructions below to build this particular flywheel design.

<h1>Fabrication of this Flywheel</h1>
This generated guide provides instructions for cutting out the web in the flywheel design shown above.
This guide does not cover details of the Z dimension.  It is expected the flywheel will initially be
turned on the lathe.  Face the flywheel on both sides.  Bore the axle hole, which could be smaller
than the final hole if the flywheel must be fitted to a mandrel or fitted for a guide for centering on the rotary
table (RT).  Trepan the flywheel.  i.e., turn the webs in preparation for the cutout procedure below.
The flywheel can return to the lathe after performing the web cutouts if desired.

<h2>Orientation</h2>
Note that the angles for the flywheel are dimensioned such that 0 degrees is pointing "up."  When the flywheel
is centered on an RT on the mill, this "up" direction could be aligned with either the Y axis or the X axis.  Which
axis is used does really matter, so the instructions from here on will be vague about this.  There may be a
slight advantage to using X as cutting operation may be easier to see.
<p>
In these instructions spokes are numbered from 1, which is the spoke facing "up," and they go around in a clockwise
direction.  In general the web cutouts will be performed in a clockwise direction for this reason.  If for some reason
your rotary table works better counterclockwise, there is no reason that can't be done.  Just be consistent to avoid
backlash and, more importantly, confusion.
<p>
Here are the spoke angles for this particular flywheel design.  Cuts will not be performed directly along these angles
as these identify the centerlines of the spokes, but it should be noted that often moving from one position to another
will span this angle increment.  <b>Hint:</b> the angles are greatly simplified if they are a multiple of the turn
of a crank on the RT.  This may be something like 4 degrees.  The design of the flywheel can usually be tweaked so
this is the case, and working the RT becomes much easier.
<p>
Finally, note that degrees are shown rounded to tenths.  A tenth of a degree is 6 minutes, 0 seconds.  This
should be accurate enough for flywheel web cutouts.

<table id="spokeTable"  style="text-align: right; width: 10em;">
<caption><b>Table 1: Spoke angles</b></caption>
<tr><th>Spoke</th><th>Angle</th></tr>
</table>

<h2>Order of Operations</h2>
There are many ways to cut out the webs of the flywheel, but this ordering works well and is what will be described here.
As mentioned earlier, it is assumed the flywheel has been faced and trepanned on the lathe, and a center bore has been
made, whether sized for the final axle or not, so that the flywheel webs can be cut.  The center hole will be the key datum
from which measurements will be made.
<ol>
<li>Drill the leftmost inner holes for the cutouts.
<li>Drill the rightmost inner holes for the cutouts (if there are any -- 3-hole cutouts are common).
<li>Drill the leftmost outer holes for the web cutouts.
<li>Drill the rightmost outer holes for the web cutouts.
<li>Cut the right (clockwise) side of each spoke.
<li>Cut the left side of each spoke.
<li>Cut the outer arc of the web cutout.
<li>Cut the inner arc if it is a 4-hole cutout.
</ol>

<h2>Setup</h2>
Center and clamp the flywheel on the RT.  The clamps must not obstruct drilling and cutting operations.
Center the RT under the mill.  Zero the RT and mark the flywheel so it is obvious where the 0 (spoke #1) is located.
Many operations will reset to this position as their first step.

<h2>Drill the Inner Holes</h2>
The inner holes for this flywheel design are <b id="inTabDia">0</b> diameter.  These holes will be drilled
at an offset <b id="inTabDist">0</b> from the center of the flywheel by
shifting the center of the rotary table in X or Y.  <span id="inTab4holeMsg"></span>
Advancing from hole to hole in this manner is done by rotating the RT <b id="instRTspokeAngle1">0</b> degrees for each.
Return the RT back to 0 degrees when done.
<p>
<table id="innerHoleTable" style="text-align: right; width: 12em;">
<caption><b>Table 2: Inner hole angles</b></caption>
<tr><th>Spoke</th><th colspan="2">Angle</th></tr>
</table>

<h2>Drill the Outer Holes</h2>
The outer holes are <b id="outTabDia">0</b> diameter.  These holes will be drilled
at an offset <b id="outTabDist">0</b> from the center of the flywheel by
shifting the center of the rotary table in X or Y.  Use care to reset the distance from the center
as the RT was offset for the previous drilling of inner holes.  It may be best to re-center the RT
and adjust the offset from there to avoid error.
<p>
There are two holes to drill on the clockwise side of each spoke.
The angles are listed. It is less error prone to drill the left hole for each spoke first, and then go around again drilling the right.
Advancing from hole to hole in this manner is done by rotating the RT <b id="instRTspokeAngle2">0</b> degrees for each.
Return the RT back to 0 degrees when done.
<p>
<table id="outerHoleTable"  style="text-align: right; width: 12em;">
<caption><b>Table 3: Outer hole angles</b></caption>
<tr><th>Spoke</th><th colspan="2">Angle</th></tr>
</table>

<h2>The Spoke Cutting</h2>
At the point the "corners" of the web cutouts have been defined with drilled holes.
Now the sides of the web cutouts along the spoke edges will be milled.  For best results,
use an end mill equal to or smaller than the smallest hole diameter.  The mill will cut from
an inner hole to the corresponding outer hole.
<p>
To position for this cut, start with spoke number 1 by ensuring the RT is centered
on the mill and returned to the zero position.  See the figure below for <b>Step 1</b>.
Now rotate the RT exactly
<b id="instRTrotate">0</b> degrees clockwise, which is a setting specific to this particular
flywheel design.  See the figure below for this clockwise rotation for <b>Step 2</b>.
The cut on the left side of the end mill should now be in
line to make this cut, except that the X or Y needs to be offset
by <b id="instRToffset">0</b> to account for the spoke thickness.
See the figure below for this sideways shift in <b>Step 3</b>.
Again, this
offset is specific to this flywheel design.  This offset must be further
increased by half the diameter (radius) of the end mill being used to cut the
spoke.  See the figure below for the end mill radius shift in <b>Step 4</b>.
<b>Don't forget to account for the cutter diameter!</b>
<p>
Before cutting, lower the mill head without plunging into either hole and verify
the cutter will cut from the left side of the inner hole to the left side of the
outer hole.  If all looks good, note the current Y (or X) position and slightly
increase the distance.  Now the cut can be made, potentially in multiple depth
passes depending on the capability of the mill.  Once it is completely cut
through, reset Y (or X) and make the final finish pass at the exact offset.
<p>
This cut the right side of spoke number 1.  Now use the RT to rotate past spoke
number 2 and do the same cut to the right of that spoke.  This will be a simple
<b id="instRTspokeAngle3">0</b> rotation from the current cut for this flywheel
design.  Don't change other settings, except jog the Y (or X) for the rough
cut vs. the finish cut.  Repeat until all the right sides of the spokes are cut.
<p>
<div style="float:left;">
<canvas id="instSpokeStep1Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 1: initial setup</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep2Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 2: rotate for cut</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep3Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 3: shift sideways</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep4Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 4: adjust for endmill</b>
</div>
<br style="clear: both">
<p>
Now the left side of each spoke must be cut.  <b>Return the RT back to zero.</b>
Now back up the RT by advancing clockwise <b id="instRTrotateLeft">0</b> degrees.
Now the right side of the end mill should be
in line to make this cut, except that the X or Y needs to be offset the other way
by <b id="instRToffsetBack">0</b> to account for the spoke thickness.  And again,
account for the end mill diameter by adjusting further for half the cutter diameter.
<p>
As before, lower the mill head without plunging into either hole and verify
the cutter will cut from the right side of the inner hole to the right side of the
outer hole.  If all looks good, note the current Y (or X) position and slightly
increase the distance.  Now the cut can be made, potentially in multiple depth
passes depending on the capability of the mill.  Once it is completely cut
through, reset Y (or X) and make the final finish pass at the exact offset.
Repeat until all the left sides of the spokes are cut.
<p>
The difficult part is done!

<h2>Finishing the Web</h2>
<span id="instFinish4WebMsg"></span>
<p>
Finish by cutting the outer arc.  Return the RT so that it and the flywheel
are centered under the mill. The outer arc of the web is at
<b id="instOuterArc">0</b> from the flywheel center.
This is the outer hole center distance of <b id="instOuterDist">0</b> plus
the radius of the outer hole which is  <b id="instOuterRadius">0</b>.
Offset X (or Y) by this amount, but reduced to account
for the end mill radius. Make the cut for each web being very careful NOT
to cut through a spoke!
<p>
That's it.  The flywheel may be removed from the
RT and cleaned up with files or further lathe operations.

<script>
"use strict";

var DEGSYM = "\u00B0";	// degree symbol in UTF-8 (unicode)
var units = "unknown";	// will be inches or mm
var angdigits = 1;		// Fixed at 1 decimal places for angles.
var lendigits = 0;		// will be 3 for inches and 2 for mm

/*
 * About the URL for FlywheelBuilder:
 *
 * The url uses a # sign to include input fields as part of the URL.
 * As input fields are changed while using this application, note that the
 * URL get updated to reflect the field changes.  This allows the browser
 * to bookmark the URL including the input fields.  Therefore different
 * types of flywheels may be saved.
 *
 * To keep the URL short, the input fields are given abbreviations.
 * These can get rather rough to sound out, but the following table maps
 * them (and is used by the code).
 */
 var urlstatemap = {
 	 // map short abbreviations to HTML form id names.
 	 spokes: "flywheelSpokes",
 	 units: "flywheelUnits",
 	 dia: "flywheelDiameter",
 	 rim: "flywheelRimThick",
 	 hub: "flywheelHubDiameter",
 	 shaft: "flywheelShaftDiameter",
 	 india: "flywheelInnerHoleDiameter",
 	 outdia: "flywheelOuterHoleDiameter",
 	 indis: "flywheelInnerHoleDistance",
 	 outdis: "flywheelOuterHoleDistance",
 	 inang: "flywheelInnerHoleAngle",
 	 outang: "flywheelOuterHoleAngle",
 	 curve: "flywheelCurveAngle",
 };
 
 
 /*
  * This function parses the given location hash.
  * It uses urlstatemap to translate to HTML form ids, and it will
  * update the document elements with the values it finds in the
  * hash (#) part of the URL.
  *
  * So far all values are simple so no special quoting is needed.
  * If someone tries to hand-code a URL, it can easily be mucked up.
  */
 function parsehash(hash) {
 	 // chop off the # at the start of hash
 	 hash = hash.substr(1,hash.length-1);

 	 // split the assignments apart
 	 var assignments = hash.split("&");
 	 for (var i in assignments) {
 	 	 // Now assignment[i] is a name=value pair
 	 	 var nameval = assignments[i].split("=");
 	 	 var field = urlstatemap[nameval[0]];
 	 	 if (field == undefined)	// just ignore invalid stuff
 	 	 	 continue;
 	 	 document.getElementById(field).value = nameval[1];
 	 }
 }
 
 /*
  * The reverse of parsehash.
  * This function iterates through urlstatemap and looks up each field
  * entry using the id name.  It then generates a hash that contains
  * assignments like this:
  *   #abc=value&xyz=value&jkl=value
  *
  * This string is returned.
  */
 function genhash() {
 	 var result = "";
 	 
 	 for (var id in urlstatemap) {
 	 	 var field = document.getElementById(urlstatemap[id]);
 	 	 if (result == "")
 	 	 	 result = "#";	// just starting
 	 	 else
 	 	 	 result += "&";	// another field
 	 	 result += id + "=" + field.value.trim();
 	 }
 	 return result;
 }
 
 /*
  * Handle a preset selection.
  *
  * This is incredibly easy.  The value of the preset selector box is the
  * hash part of the URL that contains all the parameters.  This makes it
  * easy to add presets by simply pasting the URL hash from a web browser
  * into this file, but it also makes this code trivial.
  *
  * To "load" the preset we set the current hash and we reset the hidden
  * urlhash field in the form.  The flywheel will update as a result of the
  * preset selector change, and buildFlywheels() will load the hash.
  */
 function selectedPreset() {
 	 location.hash = document.getElementById("flywheelPresets").value;
 	 document.getElementById("urlhash").value = "";
	 document.getElementById("prevFlywheelUnits").value = "";
 }

/*
 * Build all the flywheel pictures here.
 *
 * We calculate everything once and then draw multiple views of it.
 * This will (help) keep all the data consistent between views.
 */
function buildFlywheels() {

	// Handle presets based on the url hash #xxx goop.
	// See parsehash() and genhash() functions for the format.
	var urlhash = document.getElementById("urlhash");
	if (urlhash.value == "") {
		// This hidden input field is empty so we are on the first load.
		// Parse out the URL for the # stuff and pre-fill the form.
		parsehash(location.hash);
		urlhash.value = location.hash;
	}
	
	// Before calculating and drawing the flywheel, do some measurement
	// handling (mm vs. inches).  This may not be the best thing to do, but if
	// the units is changed we automatically convert the units in the form.
	// Angles are always degrees, but length can be mm or inches.
	// The units and lendigits are global vars for now.
	var prevunits = document.getElementById("prevFlywheelUnits").value;
	units = document.getElementById("flywheelUnits").value;
	if (units == "mm")
		lendigits = 2;
	else if (units == "in")
		lendigits = 3;
	// Now that we have rounding established, do conversions if needed.
	if (prevunits != units) {
		var conv = 0;
		if (prevunits == "mm")
			conv = 1/25.4;
		else if (prevunits == "in")
			conv = 25.4;		// if neither, we get zero
		if (conv != 0) {
			// These are length fields to convert. Keeping this list is error prone.
			var fields = [
				"flywheelDiameter",
				"flywheelRimThick",
				"flywheelHubDiameter",
				"flywheelShaftDiameter",
				"flywheelInnerHoleDiameter",
				"flywheelInnerHoleDistance",
				"flywheelOuterHoleDiameter",
				"flywheelOuterHoleDistance"
			];
			var f;
			for (f in fields) {
				var v = document.getElementById(fields[f]).value;
				v = v * conv;
				document.getElementById(fields[f]).value = v.toFixed(lendigits);
			}
		}
	}
	document.getElementById("prevFlywheelUnits").value = units;

	//
	// Now calculate the flywheel from all the values in the form.
	//
	var numSpokes = parseInt(document.getElementById("flywheelSpokes").value);
	var flydia = parseFloat(document.getElementById("flywheelDiameter").value);
	var rim = parseFloat(document.getElementById("flywheelRimThick").value);
	var hubdia = parseFloat(document.getElementById("flywheelHubDiameter").value);
	var shaftdia = parseFloat(document.getElementById("flywheelShaftDiameter").value);
	
	var inholedia = parseFloat(document.getElementById("flywheelInnerHoleDiameter").value);
	var inholedist = parseFloat(document.getElementById("flywheelInnerHoleDistance").value);
	var inholeang = parseFloat(document.getElementById("flywheelInnerHoleAngle").value);

	var outholedia = parseFloat(document.getElementById("flywheelOuterHoleDiameter").value);
	var outholedist = parseFloat(document.getElementById("flywheelOuterHoleDistance").value);
	var outholeang = parseFloat(document.getElementById("flywheelOuterHoleAngle").value);
	var curveangle = parseFloat(document.getElementById("flywheelCurveAngle").value);
	
	// Some checks to "fix" invalid flywheels.  This doesn't cover them
	// all, by any means!
	var prevspokes = document.getElementById("prevFlywheelSpokes").value;
	if (prevspokes != numSpokes) {
		// If the previous # spokes had a 3-hole cutout then keep it that way.
		if (inholeang == 180/prevspokes) {
			inholeang = 180/numSpokes;
			document.getElementById("flywheelInnerHoleAngle").value = inholeang.toFixed(angdigits);
		}
	}
	document.getElementById("prevFlywheelSpokes").value = numSpokes;
	if (inholeang > 180/numSpokes) {
		inholeang = 180/numSpokes;
		document.getElementById("flywheelInnerHoleAngle").value = inholeang.toFixed(angdigits);
	}	
	
	var fly = calculateFlywheel(
			numSpokes,					// number of spokes
			flydia/2,				// radius of flywheel
			flydia/2 - rim,			// radius of rim
			hubdia/2,				// radius of hub
			shaftdia/2,				// radius of shaft
			inholedia/2,			// radius of inner cut hole
			inholeang,				// angle of inner cut hole
			inholedist,				// distance to center of inner hole
			outholedia/2,				// radius of outer cut hole
			outholeang,				// angle of outer cut hole
			outholedist,			// distance to center of outer hole
			curveangle);			// angle for curved spokes (0 for straight)
	
	//
	// Finally draw it, and draw it again with dimension markup.
	//
	var canvas = document.getElementById("flywheelDemoCanvas");
	drawFlywheelDemo(canvas, fly);
	var canvasdims = document.getElementById("flywheelDimsCanvas");
	drawFlywheelDims(canvasdims, fly);

	if (fly.curveAngle == 0) {  // QQQ:  fix this for curved angles.
	//
	// Now do a pile of document fixups to personalize the web page
	// instructions to the flywheel design
	//
	var RTrotate = document.getElementById("RTrotate");
	var RToffset = document.getElementById("RToffset");
	var cutangle = 360 - fly.rightCutAngle;
	if (cutangle == 360)
		cutangle = 0;	// more sane
	var backangle = 360 - cutangle;
	if (backangle == 360)
		backangle = 0;	// more sane
	var cuts = rotate(fly.rightCutEdgeStart, cutangle);
	RTrotate.innerHTML = cutangle.toFixed(angdigits);
	RToffset.innerHTML = cuts.x.toFixed(lendigits);
	// More instruction customization:
	document.getElementById("instRTrotate").innerHTML = cutangle.toFixed(angdigits);
	document.getElementById("instRTrotateLeft").innerHTML = backangle.toFixed(angdigits);
	document.getElementById("instRToffset").innerHTML = cuts.x.toFixed(lendigits);
	document.getElementById("instRToffsetBack").innerHTML = cuts.x.toFixed(lendigits);
	document.getElementById("instOuterArc").innerHTML = (fly.outerHoleDistance + fly.outerHoleRadius).toFixed(lendigits);
	document.getElementById("instOuterDist").innerHTML = fly.outerHoleDistance.toFixed(lendigits);
	document.getElementById("instOuterRadius").innerHTML = fly.outerHoleRadius.toFixed(lendigits);
	document.getElementById("instRTspokeAngle1").innerHTML = fly.spokeAngle.toFixed(angdigits);
	document.getElementById("instRTspokeAngle2").innerHTML = fly.spokeAngle.toFixed(angdigits);
	document.getElementById("instRTspokeAngle3").innerHTML = fly.spokeAngle.toFixed(angdigits);
	}
	
	var ThreeHoleAngle = document.getElementById("ThreeHoleAngle");
	var angle3hole = fly.spokeAngle/2;
	ThreeHoleAngle.innerHTML = angle3hole.toFixed(angdigits);

	// Update document to show thickness of spoke ends.
	var InnerThick = document.getElementById("InnerThick");
	var OuterThick = document.getElementById("OuterThick");
	InnerThick.innerHTML = fly.innerSpokeThickness.toFixed(lendigits);
	OuterThick.innerHTML = fly.outerSpokeThickness.toFixed(lendigits);
	
	//
	// Now update cutting schedule tables.
	// Each has a single row heading, so we delete the extra rows
	// and generate new ones.  Table row indexes start at 0 (the heading).
	//
	
	var table;

	// The spokeTable.  This is just a list of the primary spoke
	// angles and is more of a reference than anything.
	table = document.getElementById("spokeTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	var spokeangle = 0;
	for (var spk=0; spk < numSpokes; spk++) {
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang = row.insertCell(1);
		spkcell.innerHTML = spk+1;   // number from 1
		spkang.innerHTML = spokeangle.toFixed(angdigits);
		spokeangle += fly.spokeAngle;
	}
	
	// The inner hole cutout table.  If the right/left inner holes are
	// identical (typical -- 3 hole cutout), then we show only one reading
	// per spoke, of course.
	// This table is oriented toward the webs.  So for each spoke the right
	// hole position is documented, followed by the next hole in the web, which
	// is really left of the *next* spoke.  That's why we add fly.spokeAngle.
	table = document.getElementById("innerHoleTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	var rightinangle = fly.rightInnerAngle;
	var leftinangle = fly.spokeAngle + fly.leftInnerAngle;
	for (var spk=0; spk < numSpokes; spk++) {
		// Always insert the right hole.
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang = row.insertCell(1);
		spkcell.innerHTML = spk+1;   // number from 1
		spkang.innerHTML = rightinangle.toFixed(angdigits);
		if (rightinangle != leftinangle) {
			// show left angle also.  Don't include the spoke # (blank)
			spkang = row.insertCell(2);
			spkang.innerHTML = leftinangle.toFixed(angdigits);
		}
		rightinangle += fly.spokeAngle;
		leftinangle += fly.spokeAngle;
	}
	// Update the message under the table with actual dimensions.
	// Is there a better way to do this?  Conditional HTML of some sort would
	// be much better.  QQQ
	document.getElementById("inTabDia").innerHTML = (fly.innerHoleRadius*2).toFixed(lendigits);
	document.getElementById("inTabDist").innerHTML = fly.innerHoleDistance.toFixed(lendigits);
	if (fly.leftInnerAngle == fly.rightInnerAngle) {
			document.getElementById("inTab4holeMsg").innerHTML =
			"This is a 3-hole web cutout, so there is only one hole to " +
			"drill on the clockwise side of each spoke.  " + 
			"The angle is listed for each spoke.";
			document.getElementById("instFinish4WebMsg").innerHTML =
			"This is a 3-hole web cutout, so only the outer arc of the web" +
			" needs to be cut for each web.";
	} else {
			document.getElementById("inTab4holeMsg").innerHTML =
			"This is a 4-hole web cutout, so there are two holes to drill " +
			"on the clockwise side of each spoke.  The angles are listed. " +
			"It is less error prone to drill the right hole for each " +
			"spoke first, and then go around again drilling the left.";
			document.getElementById("instFinish4WebMsg").innerHTML =
			"This is a 4-hole web cutout, so the inner arc of the web" +
			" needs to be cut.  Return the RT so that it and the flywheel" +
			" are centered under the mill.  The inner arc is at " +
			(fly.innerHoleDistance - fly.innerHoleRadius).toFixed(lendigits) +
			".  This is the inner hole center distance of " +
			fly.innerHoleDistance.toFixed(lendigits) +
			" less the radius of the inner hole which is " + 
			fly.innerHoleRadius.toFixed(lendigits) +
			".  Offset X (or Y) by this amount as well as an additional" +
			" distance to account for the end mill radius.  Make the cut" +
			" for each web being very careful NOT to cut through a spoke!";
	}
	
	// The outer hole cutout table.  
	table = document.getElementById("outerHoleTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	var rightoutangle = fly.rightOuterAngle;
	var leftoutangle = fly.spokeAngle + fly.leftOuterAngle;
	for (var spk=0; spk < numSpokes; spk++) {
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang1 = row.insertCell(1);
		var spkang2 = row.insertCell(2);

		spkcell.innerHTML = spk+1;   // number from 1
		spkang1.innerHTML = rightoutangle.toFixed(angdigits);
		spkang2.innerHTML = leftoutangle.toFixed(angdigits);
		
		rightoutangle += fly.spokeAngle;
		leftoutangle += fly.spokeAngle;
	}
	// Update the message under the table with actual dimensions.
	document.getElementById("outTabDia").innerHTML = (fly.outerHoleRadius*2).toFixed(lendigits);
	document.getElementById("outTabDist").innerHTML = fly.outerHoleDistance.toFixed(lendigits);
	
	if (fly.curveAngle == 0) { // QQQ: fix for curves
	// Now fill in the instSpokeStep*Canvas figures
	drawSpokeStep(1, document.getElementById("instSpokeStep1Canvas"), fly);
	drawSpokeStep(2, document.getElementById("instSpokeStep2Canvas"), fly);
	drawSpokeStep(3, document.getElementById("instSpokeStep3Canvas"), fly);
	drawSpokeStep(4, document.getElementById("instSpokeStep4Canvas"), fly);
	}
	
	// Now update the # (hash) so the URL matches the inputs
	// Thus, it can be bookmarked with the current settings.
	location.hash = genhash();
}


/*
 * Utility math functions.
 *
 * What follow are a bunch of utility functions for simple conversions
 * and calculations.  They exist partly for convenience, and partly because
 * this code wants to do the flywheel math using a coordinate system more
 * convenient for the purpose.
 *
 * Canvas coordinates for drawing are specified with 0,0 as the upper left
 * corner and X increasing to the right, and Y increasing down.  Thus, all
 * coordinates are positive.   For the flywheel it is more convenient to place
 * 0,0 at the shaft center with Y increasing up, negative Y down, X increasing
 * right, and negative X left.
 *
 * Angles here are in degrees (canvas uses radians) where 0 is up and positive
 * angles increase clockwise.  Negative angles therefore go counter(anti)-clockwise.
 */

// Angle conversions.
function radiansToDegrees(r) {
	return r * (180/Math.PI);
}
function degreesToRadians(d) {
	return d * (Math.PI/180);
}

// Many functions want a point.  Trivially construct a point object.
// Methods could be defined, but for now functions (below) are used.
function toPoint(x, y)
{
	return { x: x, y: y};
}

// This is for debug.  A point to string.
function ptStr(p)
{
	return "(" + p.x.toFixed(3) + "," + p.y.toFixed(3) + ")";
}

// Add two points returning one that is a sum.
function addPoints(p1, p2)
{
	return toPoint(p1.x + p2.x, p1.y + p2.y);
}
// Subtract p1 from p2 producing a delta point
function subtractPoints(p1, p2)
{
	return toPoint(p2.x - p1.x, p2.y - p1.y);
}
// Return a scaled point multipled by the scaling factor
function scalePoint(p, multiplier)
{
	return toPoint(p.x * multiplier, p.y * multiplier);
}

// Distance between two points.
function distance(p1, p2) {
	var dp = subtractPoints(p1, p2);
	return Math.sqrt(dp.x*dp.x + dp.y*dp.y);
}

// Midpoint between two points
function midpoint(p1, p2) {
	return toPoint((p1.x + p2.x)/2, (p1.y + p2.y)/2);
}

// Slope of a line between two points
function slope(p1, p2) {
	var diffPt = subtractPoints(p1, p2);
	return diffPt.y / diffPt.x;
}

// Calculate angle between two points.
// See general description above for the orientation
function angle(p1, p2) {
	var dp = subtractPoints(p1, p2);
	var ang = radiansToDegrees(Math.atan2(dp.x, dp.y));
	if (ang < 0)
		ang += 360;		// Use a 0..360 scale, rather than -180..180
	return ang;
}

// Return a rotated point when the axes are rotated clockwise.
function rotate(p, angleDeg) {
	var angle = degreesToRadians(-angleDeg);
	var sinAng = Math.sin(angle);
	var cosAng = Math.cos(angle);
	return toPoint(p.x * cosAng - p.y * sinAng, p.x * sinAng + p.y * cosAng);
}

/*
 * Utility drawing functions
 *
 * These replace a lot of boilerplate drawing work.
 * These functions draw in the canvas coordinate system.
 *
 * Patterns aren't implemented in IE10 and earlier.  They could probably
 * be changed to undefined and it work work with solid lines for everything.
 */

// Define some line patterns.
// These are defined by canvas as pairs of integers.  Pixels on/off.
var pattern_solid = undefined;		// default is solid, so use undefined
var pattern_dot = [2, 4];	// dot, dot-space
var pattern_dash_dot_dot = [5, 5, 2, 3, 2, 3];  // dash, dash-space, ...

// Fill
// No fill uses undefined as that is the default
// I could define some standard fills here, but I use color names for now
var fill_none = undefined;

/*
 * To save a lot of messy math as arguments to the drawing functions,
 * we create a special context object for the drawing functions you will find
 * here.  Hopefully this context won't be confused with a canvas context
 * which is included as part of this "larger" context.
 *
 * Why do we need a special drawing context?  We want to draw with coordinates
 * that are 0,0 in the center of the canvas, and we want to scale the drawing
 * to a ratio of the flywheelRadius.  Therefore the flywheel is always
 * zoomed the same.  The canvas drawing package can do scaling and transforms,
 * but these impact text drawing which is something we don't want.
 *
 */
function makeDrawingContext(canvas, radius)
{
	var flyctx = {};  // new object
	flyctx.canvas = canvas;
	flyctx.context = canvas.getContext("2d");
	flyctx.offsetx = canvas.width / 2;
	flyctx.offsety = canvas.height / 2;
	flyctx.fscale = Math.min(canvas.width, canvas.height) * 0.90 /
					(radius * 2);
	return flyctx;
}


/*
 * Draw a circle using the given color, fill, and pattern.
 *
 *	ctx		drawing context (from makeDrawingContext() above)
 *	center	center point
 *	radius	length relative to flywheel radius in the ctx
 *	color	drawing color
 *  fill	fill color (or use fill_none)
 *  pattern	choose from patterns above including pattern_solid
 */
function drawCircle(ctx, center, radius, color, fill, pattern)
{
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)  // NB: some browsers (IE<11) don't have setLineDash
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	ctx.context.arc(ctx.offsetx+center.x*ctx.fscale,
					ctx.offsety-center.y*ctx.fscale,
					radius*ctx.fscale,0,2*Math.PI);
	if (fill) {
		ctx.context.fillStyle = fill;
		ctx.context.fill();
	}
	ctx.context.stroke();
	ctx.context.restore();
}

/*
 * Draw a radial line at an angle from the given x,y starting point.
 * The angle is in degrees and we interpret it as clockwise from
 * straight up.  We could let the canvas do the rotation, but since
 * we are doing so much trig anyway, just calculate it.
 *
 *	ctx		drawing context (from makeDrawingContext() above)
 *	center	center point
 * 	angleDeg	angle in degrees (up is zero)
 *	length	length relative to flywheel radius in the ctx
 *	color	drawing color
 *  pattern	choose from patterns above including pattern_solid
 */
function drawRadialLine(ctx, center, angleDeg, length, color, pattern)
{
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	ctx.context.moveTo(ctx.offsetx+center.x*ctx.fscale,
					   ctx.offsety-center.y*ctx.fscale);
	// rotate the endpoint of a vertical (x=0) line going up (y=length)
	var dest = rotate(toPoint(0, length), angleDeg);
	// subtract y to go up because canvas has 0,0 in the upper right
	ctx.context.lineTo(ctx.offsetx+(center.x+dest.x)*ctx.fscale,
					   ctx.offsety-(center.y+dest.y)*ctx.fscale);
	ctx.context.stroke();
	ctx.context.restore();
}


/*
 * Draw a line with color and pattern
 *
  *	ctx		drawing context (from makeDrawingContext() above)
 *	start	start point
 * 	end		end point
 *	color	drawing color
 *  pattern	choose from patterns above including pattern_solid
 */
function drawLine(ctx, start, end, color, pattern)
{
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	ctx.context.moveTo(ctx.offsetx+start.x*ctx.fscale,
					   ctx.offsety-start.y*ctx.fscale);
	ctx.context.lineTo(ctx.offsetx+end.x*ctx.fscale,
					   ctx.offsety-end.y*ctx.fscale);
	ctx.context.stroke();
	ctx.context.restore();
}

/*
 * Draw an arc
 * The start/end angles are in degrees where 0 is straight up.
 *
 *	ctx		drawing context (from makeDrawingContext() above)
 *	center	center point
 *  radius	arc radius
 * 	start	start angle in degrees (up is zero)
 *	end		end angle
 *	color	drawing color
 *  pattern	choose from patterns above including pattern_solid

 */
function drawArc(ctx, center, radius, start, end, color, pattern)
{
	var srad = degreesToRadians(start-90);
	var erad = degreesToRadians(end-90);
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	ctx.context.arc(ctx.offsetx+center.x*ctx.fscale,
					ctx.offsety-center.y*ctx.fscale,
					radius*ctx.fscale, srad, erad);
	ctx.context.stroke();
	ctx.context.restore();
}

/* Same as drawRadialLine, except now drawing a dimension line.
 * This means adding arrowheads and a dimension label.
 * The labelpos is the percent of the way from start to end for the
 * center of the label.
 */
function drawRadialDim(
	ctx,		// drawing context (from makeDrawingContext() above)
	center,		// center point
	angleDeg,	// angle of dimension line
	startlen,	// start of line by length (doesn't have to start at center)
	length,		// length of dimension line
	label,		// label text 
	labelpos,	// position of label as percentage along drawn line
	color,		// color of line
	pattern)	// choose from patterns above including pattern_solid
{
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	
	// We will draw a "horizontal" line and let canvas do the rotating for us.
	// We use horizontal because that is how text is drawn.  This makes it a bit
	// more complicated because we must interpret angleDeg=0 as "up".
	// Since we want horizontal, we'll just subtract 90 degrees.
	ctx.context.translate(ctx.offsetx+center.x*ctx.fscale,
						  ctx.offsety-center.y*ctx.fscale);	// Now 0,0 is the center.
	ctx.context.rotate(degreesToRadians(angleDeg-90));

	// Adjust lengths for scale.
	startlen *= ctx.fscale;
	length *= ctx.fscale;
	
	// Now we can draw as if we are horizontal, but still must account for fscale
	ctx.context.beginPath();
	ctx.context.moveTo(startlen,0);
	ctx.context.lineTo(length, 0);
	// draw end arrowhead since we are here
	ctx.context.lineTo(length-5, -3);
	ctx.context.moveTo(length, 0);
	ctx.context.lineTo(length-5, 3);
	// draw start arrowhead
	ctx.context.moveTo(startlen,0);
	ctx.context.lineTo(startlen+5, -3);
	ctx.context.moveTo(startlen,0);
	ctx.context.lineTo(startlen+5, 3);
	// Now draw the label in the middle
	var textwidth = ctx.context.measureText(label).width;
	ctx.context.fillStyle = color;
	ctx.context.fillText(label, startlen+((length-startlen)*labelpos)-(textwidth/2), -3);
	ctx.context.stroke();
	ctx.context.restore();
}



/* This draws an angle dimension line.
 *
 * x,y			Center point of angle
 * start, end	Start/end of angle in degrees with 0 as up.
 * length		Length of dimension lines
 * label		The label to draw.  Probably end - start :)
 * labelpos		The percentage up the dimension lines to draw the
 *				dimension arc and label.
 * context, color and pattern define drawing context to use.
 */
function drawAngDim(
	ctx,		// drawing context (from makeDrawingContext() above)
	center,		// center point
	start,		// start angle
	end,		// end angle
	length,		// length of dimension lines
	label,		// label text 
	labelpos,	// position of label as percentage along drawn lines
	color,		// color of line
	pattern)	// choose from patterns above including pattern_solid
{
	var srad = degreesToRadians(start-90);
	var erad = degreesToRadians(end-90);
	var sdim = rotate(toPoint(0, length), start);
	var edim = rotate(toPoint(0, length), end);

	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	// Draw dimension lines first.
	ctx.context.moveTo(ctx.offsetx+center.x*ctx.fscale,
					   ctx.offsety-center.y*ctx.fscale);
	ctx.context.lineTo(ctx.offsetx+(center.x+sdim.x)*ctx.fscale,
					   ctx.offsety-(center.y+sdim.y)*ctx.fscale);
	ctx.context.moveTo(ctx.offsetx+center.x*ctx.fscale,
					   ctx.offsety-center.y*ctx.fscale);
	ctx.context.lineTo(ctx.offsetx+(center.x+edim.x)*ctx.fscale,
					   ctx.offsety-(center.y+edim.y)*ctx.fscale);
	ctx.context.stroke();
	ctx.context.beginPath();
	// The arc.  Not bothering with arrow heads.
	ctx.context.arc(ctx.offsetx+center.x*ctx.fscale,
					ctx.offsety-center.y*ctx.fscale,
					(length*labelpos)*ctx.fscale,srad,erad);
	ctx.context.stroke();

	// Now draw the label.  We center this on the arc and want it rotated to
	// match the arc.  Let the canvas do the rotation.  Remember up is 0 deg
	// so I need to subtract 90 to get that.  HOWEVER, we want the text 90
	// degrees from the angle anyway, so it works out without this!  Sweet.
	ctx.context.translate(ctx.offsetx+center.x*ctx.fscale,
						  ctx.offsety-center.y*ctx.fscale); // Now 0,0 is the center.
	ctx.context.rotate(degreesToRadians((start+end)/2));	// midway angle
	ctx.context.fillStyle = color;
	var textwidth = ctx.context.measureText(label).width;
	var textheight = ctx.context.measureText(label).height;
	ctx.context.fillText(label, -textwidth/2, -(length*ctx.fscale)*labelpos-5);

	ctx.context.restore();
}



/* Calculate Flywheel data
 * =======================
 *
 * This function doesn't draw anything.  It calculates all the useful
 * coordinates and angles for the flywheel.
 *
 * The input arguments are documented in the function declaration.  These
 * come from the web page user interface.  Angles are specified here in
 * degrees.  Length units are unspecified, but are assumed to be consistant
 * (i.e. use all inches or mm for lengths)
 *
 * The outputs are documented at the end of the function where an object
 * containing all this data is returned.
 *
 * Note that the coordinate system for these calculations is what you'd use
 * in a math graph.  That is, 0,0 is the center of the flywheel.  The first
 * spoke will be created straight up, and angles in the output will be measured
 * in a clockwise direction, in degrees, from this vertical spoke.
 *
 * Note also that some internal calculations within this function use a
 * rotated and transformed (shifted) coordinate system.  I'll try to document
 * this so it can be understood.
 */
function calculateFlywheel(
	numSpokes,				// 2..something reasonable.
	flywheelRadius,		// outside of flywheel in units (mm, inches, etc)
	rimRadius,			// inside of flywheel rim
	hubRadius,			// outside of hub
	shaftRadius,		// shaft size (note: radius, not diameter)
	innerHoleRadius,	// hole size used in the web near the shaft
	innerHoleAngle,		// angle of inner hole clockwise from vertical
	innerHoleDistance,	// radius of inner hole from the center
	outerHoleRadius,	// hole size used in the web near the rim
	outerHoleAngle,		// angle of outer hole clockwise from vertical
	outerHoleDistance,	// radius of outer hole from the center
	curveAngle			// twist angle of outer rim for curved spokes
) {

	// Return an object with a pile of fields, including the inputs
	var fly = {
		numSpokes: numSpokes,
		spokeAngle: 360 / numSpokes,
		spokeBisect: 180 / numSpokes,
		flywheelRadius: flywheelRadius,
		rimRadius: rimRadius,
		hubRadius: hubRadius,
		shaftRadius: shaftRadius,
		innerHoleRadius: innerHoleRadius,
		innerHoleDistance: innerHoleDistance,
		outerHoleRadius: outerHoleRadius,
		outerHoleDistance: outerHoleDistance,
		curveAngle: curveAngle,
	};
	
	// Now calculate for spoke #0 (and web clockwise from this spoke)
	// All other spokes can use this data provided it is rotated by
	// n*fly.spokeAngle, where n is the spoke #.

	// Calculate angles and coords of the 4 holes
	// Note that we take a point on the Y-axis and rotate it to trivially calculate these.
	// The left angle is negative.  This isn't surprising, but code using this data is
	// usually working with the web cutout to the right of a spoke.  Therefore,
	// fly.spokeAngle + fly.leftInnerAngle, for example, is a common calculation when
	// working with a web.  The left side of the web is the right side of a spoke, and
	// the right side of the web cutout is the left side of the *next* spoke.  This can
	// be confusing.  This data structure represents a spoke, so remember that right/left
	// are relative to the spoke, not the web.
	var inpoint = toPoint(0,innerHoleDistance);
	var outpoint = toPoint(0,outerHoleDistance);
	fly.rightInnerAngle = innerHoleAngle;
	fly.rightInnerCenter = rotate(inpoint, fly.rightInnerAngle);
	fly.rightOuterAngle = outerHoleAngle + curveAngle;		// Outer hole is twisted for curved spokes
	fly.rightOuterCenter = rotate(outpoint, fly.rightOuterAngle);
	fly.leftInnerAngle = -innerHoleAngle;
	fly.leftInnerCenter = rotate(inpoint, fly.leftInnerAngle);
	fly.leftOuterAngle = -outerHoleAngle + curveAngle;		// Outer hole is twisted for curved spokes
	fly.leftOuterCenter = rotate(outpoint, fly.leftOuterAngle);

	// Calculate drawing data for the web cutout.
	// This web is to the right (clockwise) of the spoke.
	// Therefore, some numbers are relative to the next spoke which is at fly.spokeAngle.
	
	// Calculate the finished edge outer arc.
	fly.edgeOuterArc = {};  // new object.
	fly.edgeOuterArc.radius = outerHoleDistance + outerHoleRadius;
	fly.edgeOuterArc.startAngle = fly.rightOuterAngle;
	fly.edgeOuterArc.endAngle = fly.spokeAngle + fly.leftOuterAngle;
	
	// Calculate the finished edge inner arc.
	fly.edgeInnerArc = {};  // new object.
	fly.edgeInnerArc.radius = innerHoleDistance - innerHoleRadius;
	fly.edgeInnerArc.startAngle = fly.rightInnerAngle;
	fly.edgeInnerArc.endAngle = fly.spokeAngle + fly.leftInnerAngle;
	// We will calculate 4 drawing arcs for the remaining edges of the
	// holes that were drilled.  These aren't useful on the mill, but
	// are useful when drawing the flywheel.  We already have recorded
	// the arc centers and radii as center/radius of each hole, so all
	// we need to record now is the start/end angles of each arc.
	
	// Create the objects first.  They have start/end angles.
	// The centers and radii are properties of the holes.
	// The values are dependent on curve vs. straight so will fill in below.
	fly.rightOuterHoleArc = {};
	fly.rightInnerHoleArc = {};
	fly.leftOuterHoleArc = {};
	fly.leftInnerHoleArc = {};

	if (fly.curveAngle) {
		// Curved spokes.
		//
		// Note that a curveAngle cannot be negative.
		// The spokes always curve in the clockwise direction.
		//
		// This produces the following calculated values for cutting curved spokes:
		//
		//		fly.curveAngle				input data (> 0 indicated curved spokes)
		//		fly.curveRadius				all cuts are this radius
		//		fly.curveSpokeCenter		point (x,y)  center of arc for centerline of spoke
		//		fly.curveSpokeStartAngle
		//		fly.curveSpokeEndAngle
		//		fly.curveCutRightCenter		point (x,y)
		//		fly.curveCutRightStartAngle
		//		fly.curveCutRightEndAngle
		//		fly.curveCutLeftCenter		point (x,y)
		//		fly.curveCutLeftStartAngle
		//		fly.curveCutLeftEndAngle
		//		fly.curveSpokeCenterlineEndAngle for bounding the centerline

		// Start by forming an arc from 3 points:
		//   A: The midpoint of the line between the right outer hole center
		//		and the left outer hole center of the previous spoke
		//   B: The midpoint of the line between the right inner hole center
		// 		and the left inner hole center of the previous spoke
		//   C: The center of the flywheel (this is "adjusted" to the left).
		// This makes a nicely shaped spoke.  The radius of this arc is what
		// we really need.  When we calculate the arcs for cutting, we'll use
		// this radius to compute an arc that is tangent to the inner/outer
		// holes so we get a nice transition.
		
		var ptA = midpoint(fly.leftOuterCenter, fly.rightOuterCenter);
		var ptB = midpoint(fly.leftInnerCenter, fly.rightInnerCenter);
		// Point C could be 0,0 which is always the hub center, but we "adjust" it to the left (negative).
		// We adjust point C to the right of the center of the hub.  We use the curveangle as a ratio of the spokeAngle.
		// At the full spokeAngle we will shift to the right of the center 1/2 of the innerHoleDistance.  This can go further
		// if the curveangle is allowed to exceed the spokeAngle.  We don't change Y -- it stays at zero.
		var ptC = toPoint(-(fly.innerHoleDistance/2)*(fly.curveAngle/fly.spokeAngle), 0);
				
		// Now calculate the radius given these 3 points.
		//
		// This arc will form the centerline of the spoke.  It has a center, radius, and start/end angle
		//
		// There are a couple ways to do this.  You can calculate perpendicular
		// lines off the two line segments beteen the three points and where
		// these perpendicular lines intersect is the center.
		//
		// The other way is to use the equation of a circle:
		//    (x-h)^2 + (y-k)^2 = r^2    (where ^2 represents "squared")
		// here we have 3 sets of x,y values, but h, k and r are unknown.
		// Since we have 3 sets, and 3 variables, we can solve.   This
		// produces a lot of algebra rearranging that I won't document here.
		// See http://2000clicks.com/mathhelp/GeometryConicSectionCircleEquationGivenThreePoints.aspx
		// and I'll stick to their variable names so it makes sense to the reader.
		var a=ptA.x, b=ptA.y, c=ptB.x, d=ptB.y, e=ptC.x, f=ptC.y;
		var h, k, r;
		h = (1/2)*((a*a+b*b)*(f-d) + (c*c+d*d)*(b-f) + (e*e+f*f)*(d-b)) / (a*(f-d) + c*(b-f) + e*(d-b));
		k = (1/2)*((a*a+b*b)*(e-c) + (c*c+d*d)*(a-e) + (e*e+f*f)*(c-a)) / (b*(e-c) + d*(a-e) + f*(c-a));
		r = Math.sqrt((a-h)*(a-h) + (b-k)*(b-k));
		
		fly.curveRadius = r;
		fly.curveSpokeCenter = toPoint(h,k);
		fly.curveSpokeStartAngle = angle(fly.curveSpokeCenter, ptC);
		fly.curveSpokeEndAngle = angle(fly.curveSpokeCenter, ptA);
		
		// Now we have our radius.  We'll use it to calculate the center
		// point for the two arcs we need (two cut sides of the spoke).
		//
		// We want this arc to be tangent to the inner/outer hole edges.
		// The observation is that the radius of the arc goes through the
		// center of each of these circles.
		//
		// We also know the radius of both inner and outer holes, so we
		// can subtract each of those from the arc radius to give us r1 and r2.
		// These are lengths of two sides of a triangle (two sides of the "pie"
		// that is formed by the arc.  The third side's length is the distance
		// between centers of the inner/outer holes.  Call this distance d.
		//
		//							  o (0,d) outer hole center
		//					          |\
		//					          | \
		//					          |  \r2
		//					          |   \
		//					         b|    \
		//					          |   h \
		//					          |------+ (x,y)
		//					          |     /
		//					         a|   / r1
		//                            | /
		//			------------------O--------------------- (temp rotated X,Y axes)
		//                            | (0,0) inner hole center
		//
		
		// Do these calculations for the right side first.
		// Here, the curve radius must extend from (x,y) to the other side of both inner
		// and outer holes.  So if r is this full radius we must subtrace each hole's
		// radius to get r1 and r2.
		//
		// Let's have this triangle unrotated with the outer hole center vertex
		// positioned at 0,0.  We calculated the base length as d, so the inner
		// hole vertex on the left is d,0.   Drop a line perpendicular to the
		// base and we get two left triangles.  The lengths a, b, and h are
		// unknown.  We know d=a+b, so let's find them.  When we do, we can
		// use (a,h) to represent x,y.  All we need to do is rotate the triangle
		// and then shift it by the original coords for the right vertex.
		var d = distance(fly.rightInnerCenter, fly.rightOuterCenter);
		var r1 = fly.curveRadius - fly.innerHoleRadius;
		var r2 = fly.curveRadius - fly.outerHoleRadius;
		var a = (d*d + r1*r1 - r2*r2) / (2*d);
		var h = Math.sqrt(r1*r1 - a*a);	// Pythagorean Theorem to calc the 3rd side.

		// Our point x,y above is really (h,a).  But we need to rotate it back
		// and shift it properly because it was relative to the inner hole center.
		var ang = angle(fly.rightInnerCenter, fly.rightOuterCenter);
		var xy = rotate(toPoint(h,a), ang);
		fly.curveCutRightCenter = addPoints(xy, fly.rightInnerCenter);
		fly.curveCutRightStartAngle = angle(fly.curveCutRightCenter, fly.rightInnerCenter);
		fly.curveCutRightEndAngle = angle(fly.curveCutRightCenter, fly.rightOuterCenter);
		
		// Now do calculations for the left side.
		// The left side is the "far" side of spoke, and therefore goes to the near side
		// of the inner and outer hole radii.  Other than a sign change, it is the same math.

		// The other side of the spoke is almost the same.
		// However, we use the prev holes, of course, and we must ADD to get
		// r1, r2 since we are on the near side of the holes.
		var d = distance(fly.leftInnerCenter, fly.leftOuterCenter);
		var r1 = fly.curveRadius + fly.innerHoleRadius;
		var r2 = fly.curveRadius + fly.outerHoleRadius;
		var a = (d*d + r1*r1 - r2*r2) / (2*d);
		var h = Math.sqrt(r1*r1 - a*a); // Pythagorean Theorem to calc the 3rd side.

		var ang = angle(fly.leftInnerCenter, fly.leftOuterCenter);
		var xy = rotate(toPoint(h,a), ang);
		fly.curveCutLeftCenter = addPoints(xy, fly.leftInnerCenter);
		fly.curveCutLeftStartAngle = angle(fly.curveCutLeftCenter, fly.leftInnerCenter);
		fly.curveCutLeftEndAngle = angle(fly.curveCutLeftCenter, fly.leftOuterCenter);
		
		// Next calculate the length of the centerline for drawing purposes
		//
		// Since this is a curved spoke, we really need an end-arc angle so it extends 5% beyond
		// edge of the flywheel (as with the straight spoke where the math is trivial)
		// To do this, we calculate the intersection of the circle 5% bigger than the flywheel
		// and the circle that represents the centerline.
		// See http://paulbourke.net/geometry/circlesphere/ for an explanation.  P0 represents the
		// center of the flywheel (always 0,0 which is nice), and P1 represents the center of the
		// centerline arc (fly.curveSpokeCenter).  We need to calculate P2, and this leads to P3.
		// See the webpage.  The math here tries to reflect that page is much as possible.
		//
		// We use 5% beyond rim because the centerline really can arc around and miss the flywheel
		// outer edge for heavy rotations.  We could check if d < |r1-r0| or if h is NaN.  This might
		// be an indicator that the curve is too sharp and unmachinable.
		//
		var P0 = toPoint(0,0);
		var P1 = fly.curveSpokeCenter;
		var d = distance(P0, P1);
		var r0 = fly.rimRadius*1.05;		// Use rim to make sure it fits.
		var r1 = fly.curveRadius;
		var a = (r0*r0 - r1*r1 + d*d)/(2*d);	// distance from P0 to P2 heading on the slope toward P1.
		var h = Math.sqrt(r0*r0 - a*a);			// Pythagorean formula to get 3rd side of the triangle		
		var x2 = (a * P1.x)/d;					// simple because P0 (x0,y0) is 0,0 center of flywheel
		var y2 = (a * P1.y)/d;
		var x3 = x2 - (h * P1.y)/d;				// also simple due to 0,0
		var y3 = y2 + (h * P1.x)/d;
		fly.curveSpokeCenterlineEndAngle = angle(fly.curveSpokeCenter, toPoint(x3,y3));

		// Finally, fill in the drawing arcs.  The objects have been created earlier.
		fly.rightOuterHoleArc.startAngle = fly.curveCutRightEndAngle;
		fly.rightOuterHoleArc.endAngle = fly.edgeOuterArc.startAngle;
		fly.rightInnerHoleArc.startAngle = fly.edgeInnerArc.startAngle + 180;
		fly.rightInnerHoleArc.endAngle = fly.curveCutRightStartAngle;
		fly.leftOuterHoleArc.startAngle = fly.edgeOuterArc.endAngle - fly.spokeAngle;
		fly.leftOuterHoleArc.endAngle = fly.curveCutLeftEndAngle - 180;
		fly.leftInnerHoleArc.startAngle = fly.curveCutLeftStartAngle + 180;
		fly.leftInnerHoleArc.endAngle = fly.edgeInnerArc.endAngle - fly.spokeAngle - 180;
		
		// Calculate thickness of spoke at inner and outer holes.
		//
		// Do the outer hole first.
		// We make the observation that the thickness of the spoke near the outer hole is the distance
		// between right/left arcs along the radial line from the center of the right cutline arc to the left
		// outer hole.  We find the point where each arc intersects this line, then compute the distance between them.
		//
		// This calculation is close, but not exact.  A better calculation involves calculating a line extending from
		// the point at the hole edge (we calculate this point here) to be perpendicular to the spoke centerline arc.
		// Where this perpendicular line intersects the other arc should be the thinnest spot at that end of the spoke.
		//
		// First calculate the point along the edge of the left outer hole that is on the "inside" aligned with the
		// radial line to the center of the left cutline arc.  An easy way to calculate this is to take (0,r), where
		// r is the radius of the outer hole.  This point is relative to the center of the hole.  Now rotate the point
		// using the angle of the line from the center of this hole to the center of the arc.  This is already
		// calculated as fly.curveCutLeftEndAngle. Finally, this coordinate is relative to the center of the hole,
		// so add the center of the hole to get the final coordinates.  It's easier than it sounds.
		var edgePt = toPoint(0,fly.outerHoleRadius);
		var rotPt = rotate(edgePt, fly.curveCutLeftEndAngle-180);
		fly.outerLeftSpokeThicknessPoint = addPoints(fly.leftOuterCenter, rotPt);
		var totalDistance = distance(fly.curveCutRightCenter, fly.outerLeftSpokeThicknessPoint);
		fly.outerSpokeThickness = totalDistance - fly.curveRadius;
		// Calculate the outer right thickness point for debug.
		var ang = angle(fly.curveCutRightCenter, fly.outerLeftSpokeThicknessPoint);
		var edgePt = toPoint(0,fly.curveRadius);
		var rotPt = rotate(edgePt, ang);
		fly.outerRightSpokeThicknessPoint = addPoints(fly.curveCutRightCenter, rotPt);
		
		// Now do the same for the inner spoke thickness.
		// This time use the right cut arc to find the right thickness point first.
		// Then find the left point using the left cut arc center and radius.
		var edgePt = toPoint(0,fly.innerHoleRadius);
		var rotPt = rotate(edgePt, fly.curveCutRightStartAngle);
		fly.innerRightSpokeThicknessPoint = addPoints(fly.rightInnerCenter, rotPt);
		var totalDistance = distance(fly.curveCutLeftCenter, fly.innerRightSpokeThicknessPoint);
		fly.innerSpokeThickness = fly.curveRadius - totalDistance;  // curve radius is now the "far" side
		// Calculate the inner left thickness point for debug.
		var ang = angle(fly.curveCutLeftCenter, fly.innerRightSpokeThicknessPoint);
		var edgePt = toPoint(0,fly.curveRadius);
		var rotPt = rotate(edgePt, ang);
		fly.innerLeftSpokeThicknessPoint = addPoints(fly.curveCutLeftCenter, rotPt);
		
	} else {
		// Straight spokes.
		//
		// This produces the following calculated values for cutting straight spokes:
		//		fly.rightCutEdgeStart	start point (x,y)
		//		fly.rightCutEdgeEnd		end point (x,y)
		//		fly.rightCutAngle
		//		fly.leftCutEdgeStart	start point (x,y)
		//		fly.leftCutEdgeEnd		end point (x,y)
		//		fly.leftCutAngle
		//		fly.spokeCenterlineRadius  length of radius for drawing the centerlines of spokes
		
		// The calculation is relative to the line between the inner hole center and outer hole center.
		// This is done for both left and right cut lines.
		//
		// The following very crude artwork shows the right cutline of a spoke
		// The right cutline connects with the "left" edges between outer and inner holes.
		// We work in rotated axes such that 0,0 represents the center of the inner hole,
		// and (0,d) represents the center of the outer hole.  The value d is the distance
		// between inner/outer hole centers (easily calculated).
		//
		//							 /o (outer hole center)
		//					        / |
		//					       /  |
		//					      /   |
		//					     /    |  (inner hole center)
		//			-------------+----O--------------------- (temp rotated X,Y axes)
		//                            |
		// We can trivially calculate the endpoints of the cutline in this space which has
		// been shifted and rotated.  If the inner center hole radius is i, and the outer
		// center hole radius is o, the endpoints of this line go from (-i,0) to (-o,d).
		//
		// To produce final coordinates, these two endpoints need to be rotated back to match
		// the angle of the line that connects the centers of the holes.  Finally, the result
		// must be shifted by the coordinates of the inner center hole because referred to that
		// as 0,0 when doing the math.  That is, we did "offset" math relative to that coordinate.
		//
		// Finally, once we have the endpoints of a cutline, we can calculate its angle.  We
		// fix the number of digits in this angle so it comes out consistently in calculations.
		
		// Calculate the cutline to the right of the spoke
		var rightHoleCenterAngle = angle(fly.rightInnerCenter, fly.rightOuterCenter);
		var rightHoleDistance = distance(fly.rightInnerCenter, fly.rightOuterCenter);
		var rightStart = rotate(toPoint(-fly.innerHoleRadius, 0), rightHoleCenterAngle);
		var rightEnd = rotate(toPoint(-fly.outerHoleRadius, rightHoleDistance), rightHoleCenterAngle);
		fly.rightCutEdgeStart = addPoints(fly.rightInnerCenter, rightStart);
		fly.rightCutEdgeEnd = addPoints(fly.rightInnerCenter, rightEnd);
		fly.rightCutAngle = angle(fly.rightCutEdgeStart, fly.rightCutEdgeEnd).toFixed(angdigits);
		
		// Calculate the cutline to the left of the spoke
		var leftHoleCenterAngle = angle(fly.leftInnerCenter, fly.leftOuterCenter);
		var leftHoleDistance = distance(fly.leftInnerCenter, fly.leftOuterCenter);
		var leftStart = rotate(toPoint(fly.innerHoleRadius, 0), leftHoleCenterAngle);
		var leftEnd = rotate(toPoint(fly.outerHoleRadius, leftHoleDistance), leftHoleCenterAngle);
		fly.leftCutEdgeStart = addPoints(fly.leftInnerCenter, leftStart);
		fly.leftCutEdgeEnd = addPoints(fly.leftInnerCenter, leftEnd);
		fly.leftCutAngle = angle(fly.leftCutEdgeStart, fly.leftCutEdgeEnd).toFixed(angdigits);
		
		// This is a bound for the spoke centerlines. We use 5% beyond the edge.
		fly.spokeCenterlineRadius = fly.flywheelRadius * 1.05;
		
		// Finally, fill in the drawing arcs.  The objects have been created earlier.
		fly.rightOuterHoleArc.startAngle = rightHoleCenterAngle - 90;
		fly.rightOuterHoleArc.endAngle = fly.rightOuterAngle;
		fly.rightInnerHoleArc.startAngle = fly.rightInnerAngle - 180;
		fly.rightInnerHoleArc.endAngle = rightHoleCenterAngle - 90 - 360;
		fly.leftOuterHoleArc.startAngle = fly.leftOuterAngle;
		fly.leftOuterHoleArc.endAngle = leftHoleCenterAngle - 270;
		fly.leftInnerHoleArc.startAngle = leftHoleCenterAngle + 90;
		fly.leftInnerHoleArc.endAngle = fly.leftInnerAngle - 180;
		
		// Calculate thickness of spoke at inner and outer holes.
		// This is easy with spoke zero because Y is fixed.  That is, inner/outer holes
		// are horizontally aligned and also equidistant from the spoke.
		// So just use the X dimension less the radius of the hole and double it.
		fly.innerSpokeThickness = (fly.rightInnerCenter.x - fly.innerHoleRadius)*2;
		fly.outerSpokeThickness = (fly.rightOuterCenter.x - fly.outerHoleRadius)*2;
		
	}



	return fly;
}

/*
 * Draw the Flywheel.
 *
 */
function drawFlywheelDemo(canvas, fly) {

	var flyctx = makeDrawingContext(canvas, fly.flywheelRadius);
	var center = toPoint(0,0);

	// Assigning to canvas.width will clear it
	canvas.width = canvas.width;

	// Draw the flywheel
	//
	// Shade the flywheel light gray, but fill in the web (out to the rim)
	// with a white circle.  The hub is also white, but the shaft is dark gray.

	drawCircle(flyctx, center, fly.flywheelRadius, "black", "lightgray", pattern_solid);
	drawCircle(flyctx, center, fly.rimRadius, "black", "white", pattern_solid);
	drawCircle(flyctx, center, fly.hubRadius, "black", "white", pattern_solid);
	drawCircle(flyctx, center, fly.shaftRadius, "black", "gray", pattern_solid);
	
	// Draw the radius lines for inner/outer hole pattern
	drawCircle(flyctx, center, fly.innerHoleDistance, "red", fill_none, pattern_dot);
	drawCircle(flyctx, center, fly.outerHoleDistance, "red", fill_none, pattern_dot);

	// Loop through the spokes and draw stuff using the spkinfo.
	// Note that the info for spoke position N refers to detail clockwise
	// from the spoke.  Position N=0 is straight up.
	var thisangle = 0;
	for (var spk=0; spk < fly.numSpokes; spk++) {		
		// Draw the 4 holes
		var rightInnerCenter = rotate(fly.rightInnerCenter, thisangle);
		var rightOuterCenter = rotate(fly.rightOuterCenter, thisangle);
		var leftInnerCenter = rotate(fly.leftInnerCenter, thisangle);
		var leftOuterCenter = rotate(fly.leftOuterCenter, thisangle);
		// Rather than work with the hole to the left of this spoke, we advance to the
		// left of the *next* spoke so we draw only in a clockwise fashion.
		var nextleftInnerCenter = rotate(fly.leftInnerCenter, thisangle + fly.spokeAngle);
		var nextleftOuterCenter = rotate(fly.leftOuterCenter, thisangle + fly.spokeAngle);

		drawCircle(flyctx, rightInnerCenter, fly.innerHoleRadius, "lightgray", fill_none, pattern_solid);
		drawCircle(flyctx, rightOuterCenter, fly.outerHoleRadius, "lightgray", fill_none, pattern_solid);
		drawCircle(flyctx, nextleftInnerCenter, fly.innerHoleRadius, "lightgray", fill_none, pattern_solid);
		drawCircle(flyctx, nextleftOuterCenter, fly.outerHoleRadius, "lightgray", fill_none, pattern_solid);

		// Draw the outer edge arc
		drawArc(flyctx, center, fly.edgeOuterArc.radius,
					fly.edgeOuterArc.startAngle + thisangle,
					fly.edgeOuterArc.endAngle + thisangle,
					"black", pattern_solid);
		// Draw the inner edge arc
		drawArc(flyctx, center, fly.edgeInnerArc.radius,
					fly.edgeInnerArc.startAngle + thisangle,
					fly.edgeInnerArc.endAngle + thisangle,
					"black", pattern_solid);

		if (fly.curveAngle) {
			// Curve spoke drawing.
			
			// Draw spoke centerline.   curveSpokeCenterlineEndAngle was calculated for this purpose
			var curveSpokeCenter = rotate(fly.curveSpokeCenter, thisangle);
			drawArc(flyctx, curveSpokeCenter, fly.curveRadius,
					fly.curveSpokeStartAngle + thisangle, fly.curveSpokeCenterlineEndAngle + thisangle,
					"gray", pattern_dash_dot_dot);

			// Draw right cut arc
			var curveCutRightCenter = rotate(fly.curveCutRightCenter, thisangle);
			drawArc(flyctx, curveCutRightCenter, fly.curveRadius,
					fly.curveCutRightStartAngle + thisangle, fly.curveCutRightEndAngle + thisangle,
					"black", pattern_solid);
					
			// Draw left cut arc
			var curveCutLeftCenter = rotate(fly.curveCutLeftCenter, thisangle);
			drawArc(flyctx, curveCutLeftCenter, fly.curveRadius,
					fly.curveCutLeftStartAngle + thisangle, fly.curveCutLeftEndAngle + thisangle,
					"black", pattern_solid)

			if (spk == 0) {
				drawCircle(flyctx, fly.outerLeftSpokeThicknessPoint, 2/flyctx.fscale, "green", "green", pattern_solid);
				drawCircle(flyctx, fly.outerRightSpokeThicknessPoint, 2/flyctx.fscale, "green", "green", pattern_solid);
				drawCircle(flyctx, fly.innerLeftSpokeThicknessPoint, 2/flyctx.fscale, "green", "green", pattern_solid);
				drawCircle(flyctx, fly.innerRightSpokeThicknessPoint, 2/flyctx.fscale, "green", "green", pattern_solid);
				drawCircle(flyctx, fly.curveCutLeftCenter, 2/flyctx.fscale, "green", "green", pattern_solid);
				drawCircle(flyctx, fly.curveCutRightCenter, 2/flyctx.fscale, "blue", "blue", pattern_solid);

			}
			/*if (spk == 0) {
				// draw sample centerpoints for spoke 0 only.
				// drawCircle(flyctx, curveCutRightCenter, 2/flyctx.fscale, "green", "green", pattern_solid);
			}*/
		} else {
			// Straight spoke drawing.
			
			// Draw spoke centerline
			drawRadialLine(flyctx, center, thisangle,
							fly.spokeCenterlineRadius,   		// radius + 5%
							"gray", pattern_dash_dot_dot);

			// Draw right/left cut lines
			var rightCutEdgeStart = rotate(fly.rightCutEdgeStart, thisangle);
			var rightCutEdgeEnd = rotate(fly.rightCutEdgeEnd, thisangle);
			drawLine(flyctx, rightCutEdgeStart, rightCutEdgeEnd, "black", pattern_solid);
			
			var leftCutEdgeStart = rotate(fly.leftCutEdgeStart, thisangle);
			var leftCutEdgeEnd = rotate(fly.leftCutEdgeEnd, thisangle);
			drawLine(flyctx, leftCutEdgeStart, leftCutEdgeEnd, "black", pattern_solid);
		}

		// Draw arcs to connect cut lines with cut edge arcs
		// This makes the drawing look nice.  The inner/outer holes
		// are drilled when milling and this forms these arcs as the
		// inside web is cut away.
		drawArc(flyctx, rightOuterCenter, fly.outerHoleRadius,
				fly.rightOuterHoleArc.startAngle + thisangle,
				fly.rightOuterHoleArc.endAngle + thisangle,
				"black", pattern_solid);
		drawArc(flyctx, rightInnerCenter, fly.innerHoleRadius,
				fly.rightInnerHoleArc.startAngle + thisangle,
				fly.rightInnerHoleArc.endAngle + thisangle,
				"black", pattern_solid);
		drawArc(flyctx, nextleftOuterCenter, fly.outerHoleRadius,
				fly.leftOuterHoleArc.startAngle + thisangle + fly.spokeAngle,
				fly.leftOuterHoleArc.endAngle + thisangle + fly.spokeAngle,
				"black", pattern_solid);
		drawArc(flyctx, nextleftInnerCenter, fly.innerHoleRadius,
				fly.leftInnerHoleArc.startAngle + thisangle + fly.spokeAngle,
				fly.leftInnerHoleArc.endAngle + thisangle + fly.spokeAngle,
				"green", pattern_solid);

		// Advance to next spoke angle for next iteration
		thisangle += fly.spokeAngle;
	}
}

/*
 * Draw the Flywheel dimension markings.
 * For now we draw the flywheel demo first, dim it, then draw over it.
 *
 */
function drawFlywheelDims(canvas, fly) {

	var flyctx = makeDrawingContext(canvas, fly.flywheelRadius);
	var center = toPoint(0,0);

	/* First, draw dim demo by drawing a transparent white rectangle over it.  Cool, no? :) */
	drawFlywheelDemo(canvas, fly)
	flyctx.context.save();
	flyctx.context.fillStyle="white";
	flyctx.context.globalAlpha="0.65";
	flyctx.context.fillRect(0,0,canvas.width,canvas.height);
	flyctx.context.restore();

	// Draw the web cutout holes for the first web only.
	// The demo drew all of them very lightly since we greyed it.  This highlights 
	// for dimensions we are adding here.
	drawCircle(flyctx, fly.rightInnerCenter, fly.innerHoleRadius, "black", fill_none, pattern_solid);
	drawCircle(flyctx, rotate(fly.leftInnerCenter, fly.spokeAngle), fly.innerHoleRadius, "black", fill_none, pattern_solid);
	drawCircle(flyctx, fly.rightOuterCenter, fly.outerHoleRadius, "black", fill_none, pattern_solid);
	drawCircle(flyctx, rotate(fly.leftOuterCenter, fly.spokeAngle), fly.outerHoleRadius, "black", fill_none, pattern_solid);

	// Redraw the hole distance lines in black, but keep them dotted
	drawCircle(flyctx, center, fly.innerHoleDistance, "black", fill_none, pattern_dot);
	drawCircle(flyctx, center, fly.outerHoleDistance, "black", fill_none, pattern_dot);

	// Radial dimensions from the center of the flywheel.
	// These are offset from the spokeAngle to get them out of the way of the
	// detail dimensions for cutting the webs.
	
	// Inner hole distance
	drawRadialDim(flyctx, center, fly.spokeAngle + 10,
			0, fly.innerHoleDistance,
			fly.innerHoleDistance.toFixed(lendigits), 0.75,	"black", pattern_solid);
	// Outer hole distance
	drawRadialDim(flyctx, center, fly.spokeAngle + 22.5,
			0, fly.outerHoleDistance,
			fly.outerHoleDistance.toFixed(lendigits), 0.75,
			"black", pattern_solid);
	// Rim radius
	drawRadialDim(flyctx, center, fly.spokeAngle + 32.5,
			0, fly.rimRadius,
			fly.rimRadius.toFixed(lendigits), 0.75,
			"black", pattern_solid);
	// Rim thickness
	var rim = fly.flywheelRadius - fly.rimRadius;
	drawRadialDim(flyctx, center, fly.spokeAngle + 28,
			fly.rimRadius, fly.flywheelRadius,
			rim.toFixed(lendigits), 0.50,
			"black", pattern_solid);
	// Flywheel Radius dimension (do we need diameter?)
	drawRadialDim(flyctx, center, fly.spokeAngle + 40,
			0, fly.flywheelRadius,
			fly.flywheelRadius.toFixed(lendigits), 0.70,
			"black", pattern_solid);
	
	// Hub Radius dimension is only useful as feedback from settings.
	// I place it as the last dimension and push out the label since I
	// know space is always going to be tight for the dimension to fit.
	drawRadialDim(flyctx, center, fly.spokeAngle + 75,
			0, fly.hubRadius,
			fly.hubRadius.toFixed(lendigits), 0.80,
			"black", pattern_solid);

	// Outer hole angle.  Draw this in the first web cutout.
	drawAngDim(flyctx, center, 0, fly.rightOuterAngle,
		fly.flywheelRadius,
		fly.rightOuterAngle.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);
	
	if (fly.leftOuterAngle != fly.rightOuterAngle) {  // should always be true
		drawAngDim(flyctx, center, 0, fly.spokeAngle + fly.leftOuterAngle,
			fly.flywheelRadius * 0.95,
			(fly.spokeAngle + fly.leftOuterAngle).toFixed(angdigits) + DEGSYM, 0.98,
			"black", pattern_solid);
	}
	
	// Inner hole angle.  Draw this in the first web cutout.
	drawAngDim(flyctx, center, 0, fly.rightInnerAngle,
		fly.flywheelRadius * 0.50,
		fly.rightInnerAngle.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);
	
	if (fly.leftInnerAngle != fly.rightInnerAngle) {
		// Second Inner hole angle.  Draw this in the first web cutout.
		drawAngDim(flyctx, center, 0, fly.spokeAngle + fly.leftInnerAngle,
			fly.flywheelRadius * 0.60,
			(fly.spokeAngle + fly.leftInnerAngle).toFixed(angdigits) + DEGSYM, 0.98,
			"black", pattern_solid);
	}	


	// Flywheel spoke angle.  Draw this in the last web cutout.
	drawAngDim(flyctx, center, -fly.spokeAngle, 0,
		fly.flywheelRadius * 0.91,
		fly.spokeAngle.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);

	// Add degree marks for each spoke.  Only valuable for straight spokes
	if (fly.curveAngle == 0) {
		flyctx.context.save();
		var spk;
		var thisangle = 0;
		for (spk=0; spk < fly.numSpokes; spk++) {
			var label = thisangle.toFixed(angdigits) + DEGSYM;
			var textwidth = flyctx.context.measureText(label).width;
			var dest = rotate(toPoint(0, fly.flywheelRadius*flyctx.fscale * 1.07), thisangle);
			flyctx.context.fillText(label, flyctx.offsetx+dest.x - textwidth/2, flyctx.offsety-dest.y);
			thisangle += fly.spokeAngle;
		}
		flyctx.context.restore();
	}
}

//
// Draw the Step N figure for the spoke cutting setup.
//
// We draw a very simplified flywheel for this.  The main idea is to show
// what the setup movements are to avoid any chance of confusion.
//
// Step one shows the initial setup.  We have the flywheel centered with
// spoke 1 "up".  It shows the inner/outer holes and the cut line we are
// trying to establish.
//
function drawSpokeStep(step, canvas, fly) {

	/* QQQ: There are some manually coded drawing steps here that need to be fixed.
	 */
	var context = canvas.getContext("2d");
	var offsetx = canvas.width / 2;
	var offsety = canvas.height / 2;
	var fradius =  Math.min(canvas.width, canvas.height) * 0.90 / 2;
	var fscale = fradius / fly.flywheelRadius;
	
	var flyctx = makeDrawingContext(canvas, fly.flywheelRadius);
	var center = toPoint(0,0);

	var cutangle = 0;
	var cutshift = 0;
	
	if (step > 1) {
		cutangle = 360-fly.rightCutAngle;
		if (cutangle == 360)
			cutangle = 0;	// more sane
	}
	
	if (step > 2) {
		// Calculate cut shift (cuts.x)
		var cuts = rotate(fly.rightCutEdgeStart, cutangle);
		cutshift = cuts.x;
	}
	
	if (step > 3) {
		// Further shift to show endmill radius adjustment
		cutshift += 3/fscale;
	}
	
	// Assigning to canvas.width will clear it
	canvas.width = canvas.width;
	
	// Draw the circle representing the flywheel
	drawCircle(flyctx, center, fly.flywheelRadius, "black", "lightgray", pattern_solid);
	drawCircle(flyctx, center, fly.rimRadius, "black", "white", pattern_solid);
	drawCircle(flyctx, center, fly.hubRadius, "black", "white", pattern_solid);
	drawCircle(flyctx, center, fly.shaftRadius, "black", "gray", pattern_solid);
	
	// Draw the mill's cut line
	drawLine(flyctx, toPoint(cutshift,0), toPoint(cutshift, fly.flywheelRadius*1.10), "blue", pattern_solid);

	context.save();
	// Draw a label saying it is the mill's cut line
	context.translate(offsetx+cutshift*fscale,offsety);	// Now 0,0 is the center.
	context.rotate(Math.PI/2);  // turn 90 degrees
	context.fillStyle = "blue";
	context.fillText("mill cut line", 20, -2);
	context.restore();

	// Draw the spoke 0 reference line
	drawRadialLine(flyctx, center, cutangle,
				fly.flywheelRadius*1.10,		// +10% gets it beyond the rim
				"black", pattern_dash_dot_dot);

	// Draw the inner/outer holes.
	var inctr = rotate(fly.rightInnerCenter, cutangle);
	var outctr = rotate(fly.rightOuterCenter, cutangle);
	drawCircle(flyctx, inctr, fly.innerHoleRadius, "black", fill_none, pattern_solid);
	drawCircle(flyctx, outctr, fly.outerHoleRadius,	"black", fill_none, pattern_solid);

	// Now draw the cut line in red
	// This has already been completely calculated in the spkinfo
	// but it needs rotation.
	var start = rotate(fly.rightCutEdgeStart, cutangle);
	var end = rotate(fly.rightCutEdgeEnd, cutangle);
	drawLine(flyctx, start, end, "red", pattern_solid);

	//
	// Step-specific markings.
	//
	if (step == 2) {
			// Draw rotation arc arrow.  This is not to any scale.
			var endang = 45;
			var flip = 1;	// multiplier -- no flip
			if (cutangle > 180) {
				endang = 315;  // arc all the way around for emphasis
				flip = -1;	// used for flipping the sign for the arrow math
			}
			context.beginPath();
			context.arc(offsetx,offsety,fradius*1.07,-Math.PI/2.5,degreesToRadians(endang-90));
			// We end at 45 degrees.  Make a 45 degree arrowhead which is
			// easy because it is straight up/down and left/right
			end = rotate(toPoint(0,fradius*1.07), endang);
			context.moveTo(offsetx+end.x, offsety-end.y);
			context.lineTo(offsetx+end.x, offsety-end.y-5*flip);
			context.moveTo(offsetx+end.x, offsety-end.y);
			context.lineTo(offsetx+end.x-5, offsety-end.y);
			context.stroke();
	}
	if (step > 2) {
			// Draw shift arrow.  This is not to any scale.
			context.beginPath();
			context.moveTo(canvas.width-10, 20);
			context.lineTo(canvas.width-40, 20);
			context.lineTo(canvas.width-36, 16);
			context.moveTo(canvas.width-40, 20);
			context.lineTo(canvas.width-36, 24);
			context.stroke();
	}

}

</script>

</body>
</html>