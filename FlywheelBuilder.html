<!DOCTYPE html>
<html>
<head>
<title>Flywheel Builder</title>
<!-- Copyright (C) 2015 Todd Inglett -->
<!-- License GPLv2.  See https://gnu.org/licenses/old-licenses/gpl-2.0.txt -->
<!--
For now, see the discussion at http://www.modelenginemaker.com/index.php/topic,5078.0.html
for some background and instructions on using this application.

This is fairly new and not well tested.  Double check everything and certainly
verify cuts look correct as you setup your mill.  Instructions for safely
using a mill and lathe are not covered here.  If you are just starting out,
try asking questions of all the fine and helpful people you will find at
http://www.modelenginemaker.com and you won't be disappointed!

Todd
 -->
<style>
table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
	white-space: nowrap;
}

.flydata {
<!-- magic class for an id="something:type" that will extract the value fly.something
     and format it with a named type.  Types are length and angle.
	 The entire content of the tag will be replaced, so use <b></b> or <span></span> or similar
  -->
}
.showForStraightSpoke {
<!-- magic class for an inline tag, <span>, etc, that will only show for a straight spoke design -->
	display: inline;
}
.showForCurvedSpoke {
<!-- magic class for an inline tag, <span>, etc, that will only show for a curved spoke design -->
	display: inline;
}
.showFor3HoleSpoke {
<!-- magic class for an inline tag, <span>, etc, that will only show for a 3-hole spoke design -->
	display: inline;
}
.showFor4HoleSpoke {
<!-- magic class for an inline tag, <span>, etc, that will only show for a 4-hole spoke design -->
	display: inline;
}
</style>
</head>

<body onLoad="buildFlywheels()">
<h2>Flywheel builder v1.5.5</h2>
<form name="flywheelParms" onChange="buildFlywheels()">
<!-- Use a select for spokes so crazy numbers (like fractions) can't happen -->
<canvas id="flywheelDemoCanvas" width="400" height="400"
  style="border:1px solid #d3d3d3;">
Your browser does not support the canvas element.  Sorry, this web page won't work for you.
</canvas>
<canvas id="flywheelDimsCanvas" width="400" height="400"
  style="border:1px solid #d3d3d3;">
</canvas>
<p><b>Dimensions:   </b>
Spokes: <select id="flywheelSpokes">
		<option value="3">3</option>
		<option value="4">4</option>
		<option value="5" selected>5</option>
		<option value="6">6</option>
		</select>
Units: <select id="flywheelUnits">
		<option value="mm">mm</option>
		<option value="in" selected>inches</option>
		</select>
Presets:  <select id="flywheelPresets" onchange="selectedPreset()">
		<option value="">Choose a Pre-designed Flywheel</option>
		<option value="spokes=6&units=in&dia=2.5&rim=0.25&hub=0.500&shaft=0.250&india=0.250&outdia=0.125&indis=0.438&outdis=0.875&inang=30.0&outang=8.2&curve=0">
		2.5" Diameter 6-spoke from Elmers #24 Beam</option>
		<option value="spokes=4&units=in&dia=3.0&rim=0.375&hub=0.625&shaft=0.250&india=0.250&outdia=0.250&indis=0.438&outdis=1.000&inang=32.0&outang=12.0&curve=0">
		3" Diameter 4-spoke Simple</option>
		<option value="spokes=6&units=in&dia=3.0&rim=0.375&hub=0.500&shaft=0.250&india=0.188&outdia=0.125&indis=0.438&outdis=1.000&inang=30.0&outang=9.0&curve=0">
		3" Diameter 6-spoke from Elmer's #5 Geared</option>
		<option value="spokes=5&units=in&dia=4.0&rim=0.312&hub=0.625&shaft=0.313&india=0.375&outdia=0.188&indis=0.625&outdis=1.438&inang=36.0&outang=8.0&curve=0">
		4" Diameter 5-spoke Thick</option>
		<option value="spokes=5&units=in&dia=4.0&rim=0.188&hub=0.625&shaft=0.313&india=0.375&outdia=0.188&indis=0.625&outdis=1.625&inang=36.0&outang=8.0&curve=0">
		4" Diameter 5-spoke Thin</option>
		<option value="spokes=6&units=in&dia=5.0&rim=0.094&hub=0.875&shaft=0.375&india=0.625&outdia=0.188&indis=0.875&outdis=2.125&inang=30.0&outang=6.0&curve=0">
		5.0" 6-spoke Easton &amp; Anderson Grasshopper</option>
		<option value="spokes=6&units=in&dia=6.5&rim=0.250&hub=0.625&shaft=0.313&india=0.25&outdia=0.188&indis=0.625&outdis=2.75&inang=24&outang=4.6&curve=0">
		6.5" Diameter 6-spoke Thin</option>

		</select>
		
<input id="prevFlywheelSpokes" value="0" type="hidden">
<input id="prevFlywheelUnits" value="none" type="hidden">
<input id="urlhash" value="" type="hidden">

<table style="text-align: left">
<tr><td>Flywheel diameter </td> <td><input id="flywheelDiameter" type="text" value="4.000" size="4" maxlength="8"></td>
    <td>Rim Thickness </td> <td><input id="flywheelRimThick" type="text" value="0.312" size="4" maxlength="8"></td></tr>
<tr><td>Hub diameter     </td> <td><input id="flywheelHubDiameter" type="text" value="0.625" size="4" maxlength="8"></td>
    <td>Shaft diameter   </td> <td><input id="flywheelShaftDiameter" type="text" value="0.313" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole diameter</td> <td><input id="flywheelInnerHoleDiameter" type="text" value="0.375" size="4" maxlength="8"></td>
    <td>Outer hole diameter</td> <td><input id="flywheelOuterHoleDiameter" type="text" value="0.188" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole distance</td> <td><input id="flywheelInnerHoleDistance" type="text" value="0.625" size="4" maxlength="8"></td>
    <td>Outer hole distance</td> <td><input id="flywheelOuterHoleDistance" type="text" value="1.438" size="4" maxlength="8"></td></tr>
<tr><td>Inner hole angle</td> <td><input id="flywheelInnerHoleAngle" type="text" value="36.0" size="4" maxlength="8"></td>
    <td>Outer hole angle</td> <td><input id="flywheelOuterHoleAngle" type="text" value="8.0" size="4" maxlength="8"></td></tr>
</table>
<br>
Curve Angle: <input id="flywheelCurveAngle" type="text" value="0" size="3" maxlength="8">
</form>

<p>
The inner spoke thickness is <b class="flydata" id="innerSpokeThickness:length">0</b> and the outer spoke
thickness is <b class="flydata" id="outerSpokeThickness:length">0</b>.
<span class="showFor4HoleSpoke">
This is a 4-hole web cutout.  Use an inner hole angle of <b class="flydata" id="spokeBisect:angle"></b> to have a 3-hole web cutout.</span>

<p class="showForStraightSpoke">
This is a straight spoke flyweel.  The rotary table must be rotated <b class="flydata" id="cutRotationAngle:angle">0</b>
 (<span class="flydata" id="cutRotationAngle:angledms">0</span>)
degrees clockwise to bring the spoke edge parallel to the mill axis.  The table must be offset by
x=<b class="flydata" id="cutPosition.x:length">0</b> plus half the cutter diameter.  See the step-by-step
instructions below to build this particular flywheel design.

<p class="showForCurvedSpoke">
This is a curved spoke flywheel.  A fixture must be built to mill the curved spokes.
This fixture must offset the center of the flywheel <b class="flydata" id="curveRadius:length">0</b>
from the center of the RT.
The left cut center is
(<span class="flydata" id="curveCutLeftCenter.x:length">0</span>,<span class="flydata" id="curveCutLeftCenter.y:length">0</span>)
and the right cut center is
(<span class="flydata" id="curveCutRightCenter.x:length">0</span>,<span class="flydata" id="curveCutRightCenter.y:length">0</span>)
from the flywheel hub center.

<h1>Fabrication of this Flywheel</h1>
This generated guide provides instructions for cutting out the web in the flywheel design shown above.
This guide does not cover details of the Z dimension.  It is expected the flywheel will initially be
turned on the lathe.  Face the flywheel on both sides.  Bore the axle hole, which could be smaller
than the final hole if the flywheel must be fitted to a mandrel or fitted for a guide for centering on the rotary
table (RT).  Trepan the flywheel.  i.e., turn the webs in preparation for the cutout procedure below.
The flywheel can return to the lathe after performing the web cutouts if desired.

<h2>Orientation</h2>
Note that the angles for the flywheel are dimensioned such that 0 degrees is pointing "up."  When the flywheel
is centered on an RT on the mill, this "up" direction could be aligned with either the Y axis or the X axis.
These instructions will assume "up" along the X dimension, so on a typical mill the flywheel will be oriented so
that up/down when the RT is zeroed is along the X axis.
<p>
In these instructions spokes are numbered from 1, which is the spoke facing "up," and they go around in a clockwise
direction.  In general the web cutouts will be performed in a clockwise direction for this reason.  If for some reason
your rotary table works better counterclockwise, there is no reason that can't be done.  Just be consistent to avoid
backlash and, more importantly, confusion.
<p>
Here are the spoke angles for this particular flywheel design.  Cuts will not be performed directly along these angles
as these identify the relative angles of the spokes, but it should be noted that often moving from one position to another
will span this angle increment. The spoke angles shown in this table are simply
based on the number of spokes.  They are always very large multiples of degrees and easy to dial on any RT.

<table id="spokeTable"  style="text-align: right; width: 10em;">
<caption><b>Table 1: Spoke angles</b></caption>
<tr><th>Spoke</th><th>Angle</th></tr>
</table>

<h2>Order of Operations</h2>
There are many ways to cut out the webs of the flywheel, but this ordering works well and is what will be described here.
As mentioned earlier, it is assumed the flywheel has been faced and trepanned on the lathe, and a center bore has been
made, whether sized for the final axle or not, so that the flywheel webs can be cut.  The center hole will be the key datum
from which measurements will be made.
<ul>
<li class="showFor3HoleSpoke">Drill the inner holes for the cutouts.
<li class="showFor4HoleSpoke">Drill the leftmost inner holes for the cutouts.
<li class="showFor4HoleSpoke">Drill the rightmost inner holes for the cutouts.
<li>Drill the leftmost outer holes for the web cutouts.
<li>Drill the rightmost outer holes for the web cutouts.
<li class="showForCurvedSpoke">Drill a hole in the waste of each web cutout for a location pin for curved spoke cuts.
<li>Cut the right (clockwise) side of each spoke.
<li>Cut the left side of each spoke.
<li>Cut the outer arc of the web cutout.
<li class="showFor4HoleSpoke">Cut the inner arc
</ul>

<h2>Setup</h2>
Several of the operations will be performed on the RT while the flywheel is centered under the mill.
Center the RT under the mill.  Center and clamp the flywheel on the RT.
The clamps must not obstruct drilling and cutting operations, so look carefully at the outer hole positions.
None of the spoke cutting operations require high precision, so it is reasonable to consider moving a clamp provided
the flywheel remains well clamped by two or more other clamps when this is done.
Zero the RT and mark the flywheel so it is obvious where the 0 (spoke #1) is located.
Many operations will reset to this position as their first step.

<h2>Drill the Inner Holes</h2>
The inner holes for this flywheel design are <b class="flydata" id="innerHoleDiameter:length">0</b> diameter.  These holes will be drilled
at an offset <b class="flydata" id="innerHoleDistance:length">0</b> from the center of the flywheel by
shifting the center of the rotary table in X or Y.
<span class="showFor3HoleSpoke">
This is a 3-hole web cutout, so there is only one hole to drill on the clockwise side of each spoke.
The angle is listed for each spoke.
</span>
<span class="showFor4HoleSpoke">
This is a 4-hole web cutout, so there are two holes to drill on the clockwise side of each spoke.
The angles are listed.  It is less error prone to drill the right hole for each spoke first,
and then go around again drilling the left.
</span>
  
Advancing from hole to hole in this manner is done by rotating the RT <b class="flydata" id="spokeAngle:angle"></b> degrees for each.
Return the RT back to 0 degrees when done.
<p>
<table id="innerHoleTable" style="text-align: right; width: 12em;">
<caption><b>Table 2: Inner hole angles</b></caption>
<tr><th>Spoke</th><th colspan="2">Angle</th></tr>
</table>

<h2>Drill the Outer Holes</h2>
The outer holes are <b class="flydata" id="outerHoleDiameter:length"></b> diameter.  These holes will be drilled
at an offset <b class="flydata" id="outerHoleDistance:length"></b> from the center of the flywheel by
shifting the center of the rotary table in X or Y.  Use care to reset the distance from the center
as the RT was offset for the previous drilling of inner holes.  It may be best to re-center the RT
and adjust the offset from there to avoid error.
<p>
There are two holes to drill on the clockwise side of each spoke.
The angles are listed. It is less error prone to drill the left hole for each spoke first, and then go around again drilling the right.
Advancing from hole to hole in this manner is done by rotating the RT <b class="flydata" id="spokeAngle:angle"></b> degrees for each.
Return the RT back to 0 degrees when done.
<p>
<table id="outerHoleTable"  style="text-align: right; width: 12em;">
<caption><b>Table 3: Outer hole angles</b></caption>
<tr><th>Spoke</th><th colspan="2">Angle</th></tr>
</table>

<div class="showForCurvedSpoke">
<h2>Drill Curved-spoke Index Location Holes</h2>
The spoke cutting for curved spokes will eventually require the flywheel be clamped on a fixture (not yet -- keep it centered).
The flywheel will be located in position on this fixture by the center hub hole and the location pin
holes that are drilled in this step.  These index location holes are drilled in the
waste material of the web and are drilled in a manner similar to the inner and outer holes.
<p>
These holes will be drilled at an offset <b class="flydata" id="locationPinDistance:length"></b>
from the center of the flywheel by shifting the center of the rotary table in X or Y.
<b>These holes can be any reasonable size</b> for a pin to mate with a corresponding hole that will be
drilled in the fixture.  Thus, a standard rod size may be preferred.
<p>
The location pin hole angles are listed.
Advancing from hole to hole is done by rotating the RT <b class="flydata" id="spokeAngle:angle"></b> degrees for each.
Return the RT back to 0 degrees when done.

<table id="locationPinTable"  style="text-align: right; width: 10em;">
<caption><b>Table 4: Location Pin angles</b></caption>
<tr><th>Spoke</th><th>Angle</th></tr>
</table>
</div><!-- end showForCurvedSpoke -->

<h2>The Spoke Cutting</h2>
At this point the "corners" of the web cutouts have been defined with drilled holes.
Now the sides of the web cutouts along the spoke edges will be milled.  For the easiest operation,
use an end mill smaller than the smallest hole diameter of inside/outside holes.
The mill will cut from an inner hole to the corresponding outer hole.  A larger end mill may be used
with care if a hole is particularly small, but some cleanup filing or finishing with a small end
mill will be required to finish each cut.

<div class="showForStraightSpoke">
<p>
Cutting straight spokes requires shifting the RT under the mill and applying a rotation so
that a side of a spoke may be cut along the X axis of the mill.  The following instructions
provide the procedure and precise settings to do this for this particular flywheel.
When all is set up properly, a side of a spoke can be milled by lowering the mill cutter into
an inner hole and cutting along X until the corresponding outer hole is reached.  The flywheel
will be rotated <b class="flydata" id="spokeAngle:angle">0</b> to the next spoke and repeated
until a side of all spokes has been cut.  Then a new setup is made for the other side of the
spoke, and this is repeated for the remainder of the spokes.

<h3>Cut the right side of the first spoke</h3>
<p>
The following figures will be referenced in the step-by-step instructions that follow.
<p>
<div style="float:left;">
<canvas id="instSpokeStep1Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 1: initial setup</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep2Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 2: rotate for cut</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep3Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 3: shift sideways</b>
</div>
<div style="float:left;">
<canvas id="instSpokeStep4Canvas" width="200" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Step 4: adjust for endmill</b>
</div>
<br style="clear: both">
<p>
To position for this cut, start with spoke number 1 by ensuring the RT is centered
on the mill and returned to the zero position.  See the figure for <b>Step 1</b>.
<p>
Now rotate the RT exactly <b class="flydata" id="cutRotationAngle:angle">0</b> 
(<span class="flydata" id="cutRotationAngle:angledms">0</span>)
degrees clockwise, which is a setting specific to this particular
flywheel design.  See the figure for this clockwise rotation for <b>Step 2</b>
and observe that this rotation brings the cut line (shown in red) in parallel with the X axis (up/down).
<p>
Now Y needs to be offset
by <b class="flydata" id="cutPosition.x:length">0</b> to account for the spoke thickness.
See the figure for this sideways shift in <b>Step 3</b>.
Again, this
offset is specific to this flywheel design.  This offset must be further
increased by half the diameter (radius) of the end mill being used to cut the
spoke.  See the figure for the end mill radius shift in <b>Step 4</b>.
<b>Don't forget to account for the cutter diameter!</b>
<p>
Before cutting, lower the mill head without plunging into either hole and verify
the cutter will cut from the left side of the inner hole to the left side of the
outer hole.  If all looks good, note the current Y position and slightly
increase the distance.  Now the cut can be made, potentially in multiple depth
passes depending on the capability of the mill.  Once it is completely cut
through, reset Y and make the final finish pass at the exact offset.
This offset should precisely cut from the edge of the inner hole to the edge of
the outer hole.

<h3>Cut the right side of the rest of the spokes</h3>
<p>
This cut the right side of spoke number 1.  Now use the RT to rotate past spoke
number 2 and do the same cut to the right of that spoke.  This will be a simple
<b class="flydata" id="spokeAngle:angle">0</b> degree rotation from the current cut for this flywheel
design.  <b>Don't change other settings,</b> except jog the Y for the rough
cut vs. the finish cut as was done for spoke 1.  Repeat until all the right sides of the spokes are cut.

<h3>Cut the left side of the spokes</h3>
<p>
Now the left side of each spoke must be cut.  <b>Return the RT back to zero.</b>
Now back up the RT by advancing clockwise <b class="flydata" id="returnRotationAngle:angle">0</b> 
(<span class="flydata" id="returnRotationAngle:angledms">0</span>) degrees.
Now the right side of the end mill should be
in line to make this cut, except that the Y needs to be offset <i>the other way</i>
by <b class="flydata" id="cutPosition.x:length">0</b> to account for the spoke thickness.  And again,
account for the end mill diameter by adjusting <i>further away</i> for half the cutter diameter.
<p>
As before, lower the mill head without plunging into either hole and verify
the cutter will cut from the right side of the inner hole to the right side of the
outer hole.  If all looks good, note the current Y position and slightly
increase the distance.  Now the cut can be made, potentially in multiple depth
passes depending on the capability of the mill.  Once it is completely cut
through, reset Y and make the final finish pass at the exact offset.
Repeat until all the left sides of the spokes are cut.
</div><!-- end showForStraightSpoke -->

<div class="showForCurvedSpoke">
<p>
Cutting curved spokes requires the construction of a fixture to hold the flywheel in position
so the RT may be used to sweep out the arc to be cut by the mill on the left (outside) and right (inside)
of each spoke.  The fixture positions the flywheel by the center hub hole and a location pin hole
drilled earlier in each waste area of the web cutout.
<p>
Note that the flywheel may be removed from the RT at this time.  It may be useful to experiment with
the flywheel blank in order to create a fixture of a size that fits well on the RT.
<h3>The cutting fixture</h3>
<p>
The fixture is a metal plate.  The thickness of the plate doesn't particularly matter unless the
flywheel is offset off the edge of the RT in which case the fixture must be rigid enough to
support the cutting operation.  If the entire assembly rests on the RT, the main concern is that holes
in the plate be reasonable enough to locate pins.  Sheet metal probably won't do.
<p>
The following figures show the fixture layout and how the fixture will be placed under the flywheel
for a cutting operation.

<div style="float:left;">
<canvas id="fixtureLayoutFigure" width="300" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Fixture Layout</b>
</div>
<div style="float:left;">
<canvas id="fixturePlacementFigure" width="300" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<br><b>Fixture Position for Cut</b>
</div>
<br style="clear: both">
<p>
Relative positions for the locations in the fixture layout are provided in this table.  It can be seen
that these are all relative to point <b>A</b> so they will need to be shifted inland onto the fixture plate.

<table style="text-align: right; width: 10em;">
<caption><b>Table 5: Fixture layout locations</b></caption>
<tr><th>Point</th><th>X</th><th>Y</th></tr>
<tr><td>A</td><td class="flydata" id="fixtureA.x:length">0</td><td class="flydata" id="fixtureA.y:length">0</td></tr>
<tr><td>B</td><td class="flydata" id="fixtureB.x:length">0</td><td class="flydata" id="fixtureB.y:length">0</td></tr>
<tr><td>C</td><td class="flydata" id="fixtureC.x:length">0</td><td class="flydata" id="fixtureC.y:length">0</td></tr>
<tr><td>D</td><td class="flydata" id="fixtureD.x:length">0</td><td class="flydata" id="fixtureD.y:length">0</td></tr>
</table>

<p>
Point <b>A</b> is the center of the flywheel and point <b>B</b> is for a location pin to align the flywheel on the
fixture for accurate clamping.  The fixture in the diagram is shown with a width of
<b class="flydata" id="fixtureSize.x:length">0</b>, a height of <b class="flydata" id="fixtureSize.y:length">0</b>,
and the relative position of point A is offset
(<b class="flydata" id="fixtureOffset.x:length">0</b>,<b class="flydata" id="fixtureOffset.x:length">0</b>) from the
lower left corner.  The fixture plate can vary considerably from these dimensions as long as the flywheel can be
supported and clamped.  Note that if the flywheel is not hanging off the edge of the flywheel, shims the thickness of
the plate can be used for clamping to allow a narrower/shorter plate to be used.
<p>
Points <b>C</b> and <b>D</b> will be used as centering points for the fixture+flywheel to be centered on the RT.
Keep this in mind when laying out the size of the fixture.  These points will be centered on the RT, so the flywheel
could be hanging off the edge of a small RT.  Points <b>C</b> and <b>D</b> might simply be punched so the fixture
can be centered and clamped to the RT at one of the points.  Alternatively, these might be holes that fit an
alignment fitting that fits in the center of the RT.  Note that these points may be close together.
<p>
Note that many holes have already been drilled in the flywheel, and these might be leveraged for clamping.
Simply create the fixture with pins installed at points A and B such that the flywheel fits without play.  Once the
flywheel is positioned, the holes can be transfered to the fixture plate with center punches.  They may be drilled
and tapped for clamping bolts if the fixture plate is of a substantial thickness.
<p>
One final note on the fixture is that the cutting operations shouldn't cut into the fixture plate, so it may be
reused for other purposes, including as a fixture plate for other flywheels.  The point locations will
differ for different designs, but they might be shifted to avoid interference with previously drilled holes.

<h3>Cut the right side of the first curved spoke</h3>
An arc radius of <b class="flydata" id="curveRadius:length">0</b> will be used for cutting all the spokes.
This same arc radius is used for both the right and left sides of the spokes, but the center point on the fixture
will be different.  The right cut will cut the line as shown in the following figure.
<p>
<canvas id="fixtureRightCutPlacementFigure" width="300" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<p>
Center the RT under the mill head.  Now center point <b>D</b> of the fixture plate onto the center of the RT and
clamp the fixture leaving room to allow the flywheel to be later placed without removing all the
clamps.  This could be done with a minimal set of clamps because the flywheel will eventually be clamped down
and this should provide more cutting support.  For now leave the flywheel off.  The RT will be rotated for cuts so
the RT need not be zeroed nor does the fixture need to be aligned along X or Y.  Angle readings won't be used.
<p>
Next, shift the RT in X to account for the cutting radius of <b class="flydata" id="curveRadius:length">0</b>
<b>less half the cutting diameter of the end mill.</b>  Place the flywheel hub on the pin at point <b>A</b> on the
fixture and with the first spoke's location pin hole over the location pin at point <b>B</b>.  <b>Clamp the flywheel.</b>
Without running the mill, verify it can plunge into the inner hole and sweep to the outer hole.
<p>
For the cut, shift the RT a tiny bit more in X away from the spoke edge.  Now run the mill using the RT to sweep out the
cut.  This could be performed in multiple depth passes depending on the capability of the mill.  Finally, shift the RT back
to the exact radius, <b>still accounting for half the cutting diameter</b>, and run the final pass.  It should
intersect the inner and outer hole edges perfectly.

<h3>Cut the right side of the rest of the curved spokes</h3>
Now that the right side (inside) of the first spoke is cut, the right sides of the rest of the spokes need to be cut.
<p>
To do this, leave the RT position as-is.  Unclamp the flywheel being very careful not to disturb the centered position
of the fixture on the RT.  This means at least one clamp must be holding it down unless another method has been
arranged to keep it centered.  Carefully lift the flyweel off pins <b>A</b> and <b>B</b>, rotate it to the next spoke position,
drop it back on pins <b>A</b> and <b>B</b> in this position, and clamp it down again.  Now it should be ready for
the next spoke cut.  Without powering the mill, check that this is true.
<p>
Now, as before, shift the mill slightly away from the spoke in X and make the rough cut using multiple passes to get
to depth.  Then shift the mill back to the correct X and make the final pass.   Repeat this procedure for the right
side of all the spokes.

<h3>Cut the left side of the curved spokes</h3>
The left (outer) sides of each spoke are cut in a similar manner to the right side.  To prepare for this, unclamp the
fixture from the RT and now center point <b>C</b> on the RT.  To do this, re-center the RT under the mill head, center and
clamp the fixture on point <b>C</b>, and then move the RT along X for the <b class="flydata" id="curveRadius:length">0</b>
radius.  This time <b>it must be <i>increased</i> by half the cutter radius</b> so the cutter cuts on the inside of the arc.
The left cut is shown in the following figure.
<p>
<canvas id="fixtureLeftCutPlacementFigure" width="300" height="200"
  style="border:1px solid #d3d3d3;">
</canvas>
<p>
As before, place the flywheel on the fixture and clamp it down.  Without power, make sure the mill will correctly sweep
out the outside edge of the spoke and connects correctly with the inside edges of the inner/outer spoke holes.  Once this
looks correct, move it out a little more for the rough passes and make the cut.  Return to the correct radius,
<b>still accounting for half the cutting radius</b> and make the final pass.   Repeat this for each spoke.
</div><!-- end showForCurvedSpoke -->

<p>
The difficult part is done!

<h2>Finishing the Web</h2>
<span class="showFor3HoleSpoke">
This is a 3-hole web cutout, so only the outer arc of the web needs to be cut.  The inner hole already drilled forms the inner arc.
</span>
<span class="showFor4HoleSpoke">
This is a 4-hole web cutout, so the inner arc of the web needs to be cut.
Return the RT so that it and the flywheel are centered under the mill.
The inner arc is at <b class="flydata" id="innerArc:length">0</b>.
This is the inner hole center distance of <b class="flydata" id="innerHoleDistance:length">0</b>
less the radius of the inner hole which is <b class="flydata" id="innerHoleRadius:length">0</b>. 
Offset X (or Y) by this amount <b>as well as an additional distance to account for the end mill radius.</b>
Make the cut for each web being very careful NOT to cut through a spoke!
</span>
<p>
Finish by cutting the outer arc.  Return the RT so that it and the flywheel
are centered under the mill. The outer arc of the web is at
<b class="flydata" id="outerArc:length">0</b> from the flywheel center.
This is the outer hole center distance of <b class="flydata" id="outerHoleDistance:length">0</b> plus
the radius of the outer hole which is  <b class="flydata" id="outerHoleRadius:length">0</b>.
Offset X (or Y) by this amount, <b>but reduced to account
for the end mill radius.</b> Make the cut for each web being very careful NOT
to cut through a spoke!
<p>
That's it.  The flywheel may be removed from the
RT and cleaned up with files or further lathe operations.

<script>
"use strict";

var DEGSYM = "\u00B0";	// degree symbol in UTF-8 (unicode)
var units = "unknown";	// will be inches or mm
var angdigits = 1;		// Fixed at 1 decimal places for angles.
var lendigits = 0;		// will be 3 for inches and 2 for mm

/*
 * About the URL for FlywheelBuilder:
 *
 * The url uses a # sign to include input fields as part of the URL.
 * As input fields are changed while using this application, note that the
 * URL get updated to reflect the field changes.  This allows the browser
 * to bookmark the URL including the input fields.  Therefore different
 * types of flywheels may be saved.
 *
 * To keep the URL short, the input fields are given abbreviations.
 * These can get rather rough to sound out, but the following table maps
 * them (and is used by the code).
 */
 var urlstatemap = {
 	 // map short abbreviations to HTML form id names.
 	 spokes: "flywheelSpokes",
 	 units: "flywheelUnits",
 	 dia: "flywheelDiameter",
 	 rim: "flywheelRimThick",
 	 hub: "flywheelHubDiameter",
 	 shaft: "flywheelShaftDiameter",
 	 india: "flywheelInnerHoleDiameter",
 	 outdia: "flywheelOuterHoleDiameter",
 	 indis: "flywheelInnerHoleDistance",
 	 outdis: "flywheelOuterHoleDistance",
 	 inang: "flywheelInnerHoleAngle",
 	 outang: "flywheelOuterHoleAngle",
 	 curve: "flywheelCurveAngle"
 };
 
 
 /*
  * This function parses the given location hash.
  * It uses urlstatemap to translate to HTML form ids, and it will
  * update the document elements with the values it finds in the
  * hash (#) part of the URL.
  *
  * So far all values are simple so no special quoting is needed.
  * If someone tries to hand-code a URL, it can easily be mucked up.
  */
 function parsehash(hash) {
 	 // chop off the # at the start of hash
 	 hash = hash.substr(1,hash.length-1);

 	 // split the assignments apart
 	 var assignments = hash.split("&");
 	 for (var i in assignments) {
 	 	 // Now assignment[i] is a name=value pair
 	 	 var nameval = assignments[i].split("=");
 	 	 var field = urlstatemap[nameval[0]];
 	 	 if (field == undefined)	// just ignore invalid stuff
 	 	 	 continue;
 	 	 document.getElementById(field).value = nameval[1];
 	 }
 }
 
 /*
  * The reverse of parsehash.
  * This function iterates through urlstatemap and looks up each field
  * entry using the id name.  It then generates a hash that contains
  * assignments like this:
  *   #abc=value&xyz=value&jkl=value
  *
  * This string is returned.
  */
 function genhash() {
 	 var result = "";
 	 
 	 for (var id in urlstatemap) {
 	 	 var field = document.getElementById(urlstatemap[id]);
 	 	 if (result == "")
 	 	 	 result = "#";	// just starting
 	 	 else
 	 	 	 result += "&";	// another field
 	 	 result += id + "=" + field.value.trim();
 	 }
 	 return result;
 }
 
 /*
  * Handle a preset selection.
  *
  * This is incredibly easy.  The value of the preset selector box is the
  * hash part of the URL that contains all the parameters.  This makes it
  * easy to add presets by simply pasting the URL hash from a web browser
  * into this file, but it also makes this code trivial.
  *
  * To "load" the preset we set the current hash and we reset the hidden
  * urlhash field in the form.  The flywheel will update as a result of the
  * preset selector change, and buildFlywheels() will load the hash.
  */
 function selectedPreset() {
 	 location.hash = document.getElementById("flywheelPresets").value;
 	 document.getElementById("urlhash").value = "";
	 document.getElementById("prevFlywheelUnits").value = "";
 }
 
 /*
  * Enable/disable conditional HTML.
  *
  * HTML doesn't have conditional text, but the document generated has many
  * sections where it needs to be written one way vs another when a particular
  * attribute of the flywheel is discussed.  This is primarily straight vs. curved
  * spoke, and 3- vs 4-hole cutouts.  But there may be more conditions.
  *
  * This function assumes text is always paired.  If there is one choice,
  * there is always the "else" choice.  So the function is designed to list the
  * two choices as well as a flag that says if the first choice is chosen (or not).
  *
  * The "choices" are provided as HTML class names.  If a choice is enabled, this
  * code runs through all HTML elements with the given class and sets their
  * display style attribute to "inline."  This makes them visible.  If a choice is
  * not enabled, the attribute is "none" which effectively deletes it.
  *
  * The unfortunate side-effect of "inline" is that the HTML element is now forced
  * to be an inline element.  This is bad for headings and paragraphs.  The
  * workaround used in this document is to always use the <span> tag, which has no
  * formatting meaning anyway.  Nest this inside a <p> or whatever.
  */
 function chooseConditionalHTML(HTMLclass1, HTMLclass2, pickfirst) {
	var onHTMLclass;
	var offHTMLclass;
	if (pickfirst) {
		onHTMLclass = HTMLclass1;
		offHTMLclass = HTMLclass2;
	} else {
		onHTMLclass = HTMLclass2;
		offHTMLclass = HTMLclass1;
	}
	var onElements = document.getElementsByClassName(onHTMLclass);
	var offElements = document.getElementsByClassName(offHTMLclass);
	var i;
	for (i=0; i<onElements.length; i++) {
		// Sadly, there isn't a value that works for all tags.
		switch (onElements[i].tagName) {
			case "LI":
				onElements[i].style.display = "list-item"
				break
			case "P":
				onElements[i].style.display = "block"
				break
			default:
				onElements[i].style.display = "inline"
				break
		}
	}
	for (i=0; i<offElements.length; i++) {
		offElements[i].style.display = "none";
	}
 }

 /*
  * doHTMLSubstitutions(HTMLclass, obj)
  *
  * Do some general substitutions of data from the given object.
  * Any element of the doc with class=HTMLclass will have the content substituted.
  *
  * The id of the element defines what data will be extracted from the provided object.
  * Note that this has the potential that multiple elements in the document have the same id.
  * But that's ok, because we iterate through them by class and never look them up by id.
  * If we find browsers get picky about this, we could append a suffix _goop and remove it
  * before doing the lookup.
  *
  * The id must be in the format "field:fmt" where obj.field will be formatted given
  * specific formatting types.  For convenience, "field.subfield:fmt" is also allowed.
  * A format is required.  See the switch below for what is supported.
  */
function doHTMLSubstitutions(HTMLclass, obj) {
	var dataEle = document.getElementsByClassName(HTMLclass)
	var i
	for (i=0; i<dataEle.length; i++) {		// enumerate the class=HTMLclass elements
		var ele = dataEle[i]
		var idparts = ele.id.split(":")		// Expect field:format
		var field = idparts[0]
		var fmt = idparts[1]
		var fieldparts = field.split(".")
		var val
		if (fieldparts[0] in obj) {
			switch (fieldparts.length) {		// handle obj.field and obj.field.subfield
				case 1:
					val = obj[fieldparts[0]]
					break
				case 2:
					if (obj[fieldparts[0]]) {
						val = obj[fieldparts[0]][fieldparts[1]]
					}
					break
			}
			switch (fmt) {
				case "length":
					ele.innerHTML = val.toFixed(lendigits)
					break
				case "angle":
					ele.innerHTML = val.toFixed(angdigits)
					break
				case "angledms":
					ele.innerHTML = degreesToDMS(val.toFixed(angdigits))
					break
				default:
					ele.innerHTML = "[bad format " + ele.id + "]"
					break
			}
		} else {
				ele.innerHTML = "[undefined obj element " + ele.id + "]"
		}
	}
}

/*
 * Build all the flywheel pictures here.
 *
 * We calculate everything once and then draw multiple views of it.
 * This will (help) keep all the data consistent between views.
 */
function buildFlywheels() {

	// Handle presets based on the url hash #xxx goop.
	// See parsehash() and genhash() functions for the format.
	var urlhash = document.getElementById("urlhash");
	if (urlhash.value == "") {
		// This hidden input field is empty so we are on the first load.
		// Parse out the URL for the # stuff and pre-fill the form.
		parsehash(location.hash);
		urlhash.value = location.hash;
	}
	
	// Before calculating and drawing the flywheel, do some measurement
	// handling (mm vs. inches).  This may not be the best thing to do, but if
	// the units is changed we automatically convert the units in the form.
	// Angles are always degrees, but length can be mm or inches.
	// The units and lendigits are global vars for now.
	var prevunits = document.getElementById("prevFlywheelUnits").value;
	units = document.getElementById("flywheelUnits").value;
	if (units == "mm")
		lendigits = 2;
	else if (units == "in")
		lendigits = 3;
	// Now that we have rounding established, do conversions if needed.
	if (prevunits != units) {
		var conv = 0;
		if (prevunits == "mm")
			conv = 1/25.4;
		else if (prevunits == "in")
			conv = 25.4;		// if neither, we get zero
		if (conv != 0) {
			// These are length fields to convert. Keeping this list is error prone.
			var fields = [
				"flywheelDiameter",
				"flywheelRimThick",
				"flywheelHubDiameter",
				"flywheelShaftDiameter",
				"flywheelInnerHoleDiameter",
				"flywheelInnerHoleDistance",
				"flywheelOuterHoleDiameter",
				"flywheelOuterHoleDistance"
			];
			var f;
			for (f in fields) {
				var v = document.getElementById(fields[f]).value;
				v = v * conv;
				document.getElementById(fields[f]).value = v.toFixed(lendigits);
			}
		}
	}
	document.getElementById("prevFlywheelUnits").value = units;

	//
	// Now calculate the flywheel from all the values in the form.
	//
	var numSpokes = parseInt(document.getElementById("flywheelSpokes").value);
	var flydia = parseFloat(document.getElementById("flywheelDiameter").value);
	var rim = parseFloat(document.getElementById("flywheelRimThick").value);
	var hubdia = parseFloat(document.getElementById("flywheelHubDiameter").value);
	var shaftdia = parseFloat(document.getElementById("flywheelShaftDiameter").value);
	
	var inholedia = parseFloat(document.getElementById("flywheelInnerHoleDiameter").value);
	var inholedist = parseFloat(document.getElementById("flywheelInnerHoleDistance").value);
	var inholeang = parseFloat(document.getElementById("flywheelInnerHoleAngle").value);

	var outholedia = parseFloat(document.getElementById("flywheelOuterHoleDiameter").value);
	var outholedist = parseFloat(document.getElementById("flywheelOuterHoleDistance").value);
	var outholeang = parseFloat(document.getElementById("flywheelOuterHoleAngle").value);
	var curveangle = parseFloat(document.getElementById("flywheelCurveAngle").value);
	
	// Some checks to "fix" invalid flywheels.  This doesn't cover them
	// all, by any means!
//	var prevspokes = document.getElementById("prevFlywheelSpokes").value;
//	if (prevspokes != numSpokes) {
//		// If the previous # spokes had a 3-hole cutout then keep it that way.
//		if (inholeang == 180/prevspokes) {
//			inholeang = 180/numSpokes;
//			document.getElementById("flywheelInnerHoleAngle").value = inholeang.toFixed(angdigits);
//		}
//	}
//	document.getElementById("prevFlywheelSpokes").value = numSpokes;
//	if (inholeang > 180/numSpokes) {
//		inholeang = 180/numSpokes;
//		document.getElementById("flywheelInnerHoleAngle").value = inholeang.toFixed(angdigits);
//	}	
	
	var fly = calculateFlywheel(
			units,					// mm or in.  Hardly used, but can be ref'ed in the html.
			numSpokes,				// number of spokes
			flydia/2,				// radius of flywheel
			flydia/2 - rim,			// radius of rim
			hubdia/2,				// radius of hub
			shaftdia/2,				// radius of shaft
			inholedia/2,			// radius of inner cut hole
			inholeang,				// angle of inner cut hole
			inholedist,				// distance to center of inner hole
			outholedia/2,				// radius of outer cut hole
			outholeang,				// angle of outer cut hole
			outholedist,			// distance to center of outer hole
			curveangle);			// angle for curved spokes (0 for straight)
	


	//
	// Finally draw it, and draw it again with dimension markup.
	//
	var canvas = document.getElementById("flywheelDemoCanvas");
	drawFlywheelDemo(canvas, fly);
	var canvasdims = document.getElementById("flywheelDimsCanvas");
	drawFlywheelDims(canvasdims, fly);

	// Now customize the instructions for this flywheel.
	
	// First thing, enable/hide anything in the document based on curve/straight or
	// 3-hole/4-hole spokes.  Over time there may be more conditional text.

	// Curved-spoke vs. Straight-spoke
	chooseConditionalHTML("showForCurvedSpoke", "showForStraightSpoke", fly.curveAngle > 0);
	// 3-hole vs. 4-hole
	chooseConditionalHTML("showFor3HoleSpoke", "showFor4HoleSpoke", fly.innerHoleAngle == fly.spokeBisect);

	// Substitute content of <html class="flydata"> elements.
	// The id attribute is interpreted and the innerHTML content is updated.
	doHTMLSubstitutions("flydata", fly)
	
	//
	// Now update cutting schedule tables.
	// Each has a single row heading, so we delete the extra rows
	// and generate new ones.  Table row indexes start at 0 (the heading).
	//
	
	var table;

	// The spokeTable.  This is just a list of the primary spoke
	// angles and is more of a reference than anything.
	table = document.getElementById("spokeTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	var spokeangle = 0;
	for (var spk=0; spk < numSpokes; spk++) {
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang = row.insertCell(1);
		spkcell.innerHTML = spk+1;   // number from 1
		spkang.innerHTML = "<b>" + spokeangle.toFixed(angdigits) + "</b>";	// Always whole degrees, so no sense showing DMS.
		spokeangle += fly.spokeAngle;
	}
	
	// The inner hole cutout table.  If the right/left inner holes are
	// identical (typical -- 3 hole cutout), then we show only one reading
	// per spoke, of course.
	// This table is oriented toward the webs.  So for each spoke the right
	// hole position is documented, followed by the next hole in the web, which
	// is really left of the *next* spoke.  That's why we add fly.spokeAngle.
	table = document.getElementById("innerHoleTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	var rightinangle = fly.rightInnerAngle;
	var leftinangle = fly.spokeAngle + fly.leftInnerAngle;
	for (var spk=0; spk < numSpokes; spk++) {
		// Always insert the right hole.
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang = row.insertCell(1);
		spkcell.innerHTML = spk+1;   // number from 1
		spkang.innerHTML = "&nbsp;<b>"+rightinangle.toFixed(angdigits) + "</b> (" + degreesToDMS(rightinangle.toFixed(angdigits)) + ")";
		if (rightinangle != leftinangle) {
			// show left angle also.  Don't include the spoke # (blank)
			spkang = row.insertCell(2);
			spkang.innerHTML = "&nbsp;<b>" + leftinangle.toFixed(angdigits) + "</b> (" + degreesToDMS(leftinangle.toFixed(angdigits)) + ")";
		}
		rightinangle += fly.spokeAngle;
		leftinangle += fly.spokeAngle;
	}
	
	// The outer hole cutout table.  
	table = document.getElementById("outerHoleTable");
	// clear table (leave heading row 0)
	while (table.rows.length > 1)
			table.deleteRow(-1);	// delete last row
	var rightoutangle = fly.rightOuterAngle;
	var leftoutangle = fly.spokeAngle + fly.leftOuterAngle;
	for (var spk=0; spk < numSpokes; spk++) {
		var row = table.insertRow(-1);	// append row
		var spkcell = row.insertCell(0);
		var spkang1 = row.insertCell(1);
		var spkang2 = row.insertCell(2);

		spkcell.innerHTML = spk+1;   // number from 1
		spkang1.innerHTML = "&nbsp;<b>"+rightoutangle.toFixed(angdigits) + "</b> (" + degreesToDMS(rightoutangle.toFixed(angdigits)) + ")";
		spkang2.innerHTML = "&nbsp;<b>"+leftoutangle.toFixed(angdigits) + "</b> (" + degreesToDMS(leftoutangle.toFixed(angdigits)) + ")";
		
		rightoutangle += fly.spokeAngle;
		leftoutangle += fly.spokeAngle;
	}
	
	// Now finish with special details for curved or straight spoke instructions.
	if (fly.curveAngle) {
		// The location pin table.  
		table = document.getElementById("locationPinTable");
		// clear table (leave heading row 0)
		while (table.rows.length > 1)
				table.deleteRow(-1);	// delete last row
		var locangle = fly.locationPinAngle;
		for (var spk=0; spk < numSpokes; spk++) {
			var row = table.insertRow(-1);	// append row
			var spkcell = row.insertCell(0);
			var spkang = row.insertCell(1);
			spkcell.innerHTML = spk+1;   // number from 1
			spkang.innerHTML = "&nbsp;<b>"+locangle.toFixed(angdigits) + "</b> (" + degreesToDMS(locangle.toFixed(angdigits)) + ")"
			locangle += fly.spokeAngle;
		}
		
		drawCurvedFixtureLayout(document.getElementById("fixtureLayoutFigure"), fly);
		drawCurvedFixturePlacement(0, document.getElementById("fixturePlacementFigure"), fly);
		drawCurvedFixturePlacement(1, document.getElementById("fixtureLeftCutPlacementFigure"), fly);
		drawCurvedFixturePlacement(2, document.getElementById("fixtureRightCutPlacementFigure"), fly);
	} else {
	
		// Now fill in the instSpokeStep*Canvas figures
		drawStraightSpokeStep(1, document.getElementById("instSpokeStep1Canvas"), fly);
		drawStraightSpokeStep(2, document.getElementById("instSpokeStep2Canvas"), fly);
		drawStraightSpokeStep(3, document.getElementById("instSpokeStep3Canvas"), fly);
		drawStraightSpokeStep(4, document.getElementById("instSpokeStep4Canvas"), fly);
	}
	
	// Now update the # (hash) so the URL matches the inputs
	// Thus, it can be bookmarked with the current settings.
	location.hash = genhash();
}


/*
 * Utility math functions.
 *
 * What follow are a bunch of utility functions for simple conversions
 * and calculations.  They exist partly for convenience, and partly because
 * this code wants to do the flywheel math using a coordinate system more
 * convenient for the purpose.
 *
 * Canvas coordinates for drawing are specified with 0,0 as the upper left
 * corner and X increasing to the right, and Y increasing down.  Thus, all
 * coordinates are positive.   For the flywheel it is more convenient to place
 * 0,0 at the shaft center with Y increasing up, negative Y down, X increasing
 * right, and negative X left.
 *
 * Angles here are in degrees (canvas uses radians) where 0 is up and positive
 * angles increase clockwise.  Negative angles therefore go counter(anti)-clockwise.
 */

// Angle conversions.
function radiansToDegrees(r) {
	return r * (180/Math.PI);
}
function degreesToRadians(d) {
	return d * (Math.PI/180);
}
// Decimal degress to Deg, Min, Sec.  This returns a string.
// This is only designed for 0 <= d < 360.  It could also normalize, but doesn't.
function degreesToDMS(d) {
	var part = d;
	var deg = Math.floor(part);
	part = part - deg;
	var min = Math.floor(part * 60);
	part = part - min / 60;
	var sec = (part * 3600).toFixed(0);
	// Note that toFixed() will round rather than truncate.  Because we are
	// working with limited floating point numbering, this may round up to
	// 60 seconds more than you think.  So deal with this.  It won't round > 60.
	if (sec == 60) {
		min = min + 1;
		sec = 0;
		if (min == 60) {
			deg = deg + 1;
			min = 0;
		}
	}
	return deg.toFixed(0) + DEGSYM + min.toFixed(0) + "'" + sec + "''";
}

// Many functions want a point.  Trivially construct a point object.
// Methods could be defined, but for now functions (below) are used.
function toPoint(x, y)
{
	return { x: x, y: y};
}

// This is for debug.  A point to string.
function ptStr(p)
{
	return "(" + p.x.toFixed(3) + "," + p.y.toFixed(3) + ")";
}

// Add two points returning one that is a sum.
function addPoints(p1, p2)
{
	return toPoint(p1.x + p2.x, p1.y + p2.y);
}
// Subtract p1 from p2 producing a delta point
function subtractPoints(p1, p2)
{
	return toPoint(p2.x - p1.x, p2.y - p1.y);
}
// Return a scaled point multipled by the scaling factor
function scalePoint(p, multiplier)
{
	return toPoint(p.x * multiplier, p.y * multiplier);
}

// Distance between two points.
function distance(p1, p2) {
	var dp = subtractPoints(p1, p2);
	return Math.sqrt(dp.x*dp.x + dp.y*dp.y);
}

// Midpoint between two points
function midpoint(p1, p2) {
	return toPoint((p1.x + p2.x)/2, (p1.y + p2.y)/2);
}

// Slope of a line between two points
function slope(p1, p2) {
	var diffPt = subtractPoints(p1, p2);
	if (diffPt.x == 0) {
		diffPt.x = 0.000001;	// a hack...but close enough for calculations
	}
	return diffPt.y / diffPt.x;
}

// Calculate angle between two points.
// See general description above for the orientation
function angle(p1, p2) {
	var dp = subtractPoints(p1, p2);
	var ang = radiansToDegrees(Math.atan2(dp.x, dp.y));
	if (ang < 0)
		ang += 360;		// Use a 0..360 scale, rather than -180..180
	return ang;
}

// Return a rotated point when the axes are rotated clockwise.
function rotate(p, angleDeg) {
	var angle = degreesToRadians(-angleDeg);
	var sinAng = Math.sin(angle);
	var cosAng = Math.cos(angle);
	return toPoint(p.x * cosAng - p.y * sinAng, p.x * sinAng + p.y * cosAng);
}

/*
 * Utility drawing functions
 *
 * These replace a lot of boilerplate drawing work.
 * These functions draw in the canvas coordinate system.
 *
 * Patterns aren't implemented in IE10 and earlier.  They could probably
 * be changed to undefined and it work work with solid lines for everything.
 */

// Define some line patterns.
// These are defined by canvas as pairs of integers.  Pixels on/off.
var pattern_solid = undefined;		// default is solid, so use undefined
var pattern_dot = [2, 4];	// dot, dot-space
var pattern_dash_dot_dot = [5, 5, 2, 3, 2, 3];  // dash, dash-space, ...

// Fill
// No fill uses undefined as that is the default
// I could define some standard fills here, but I use color names for now
var fill_none = undefined;

/*
 * To save a lot of messy math as arguments to the drawing functions,
 * we create a special context object for the drawing functions you will find
 * here.  Hopefully this context won't be confused with a canvas context
 * which is included as part of this "larger" context.
 *
 * Why do we need a special drawing context?  We want to draw with coordinates
 * that are 0,0 in the center of the canvas, and we want to scale the drawing
 * to a ratio of the flywheelRadius.  Therefore the flywheel is always
 * zoomed the same.  The canvas drawing package can do scaling and transforms,
 * but these impact text drawing which is something we don't want.
 *
 */
function makeDrawingContext(canvas, radius)
{
	var flyctx = {}  // new object
	flyctx.canvas = canvas
	flyctx.context = canvas.getContext("2d")
	var mindim = Math.min(canvas.width, canvas.height)
	flyctx.offsetx = mindim / 2
	flyctx.offsety = flyctx.offsetx
	flyctx.fscale =  mindim * 0.90 / (radius * 2)
	return flyctx
}

/*
 * Draw text at a given position
 *
 *	ctx		drawing context (from makeDrawingContext() above)
 *	pos		center point
 *  offset	offset (in pixels -- not scaled)
 *  text	text to draw
 */
function drawText(ctx, pos, offset, text)
{
	ctx.context.save()
	ctx.context.font = "10pt Arial"
	ctx.context.fillText(text, ctx.offsetx+pos.x*ctx.fscale+offset.x, ctx.offsety-pos.y*ctx.fscale-offset.y)
	ctx.context.restore()
}


/*
 * Draw a circle using the given color, fill, and pattern.
 *
 *	ctx		drawing context (from makeDrawingContext() above)
 *	center	center point
 *	radius	length relative to flywheel radius in the ctx
 *	color	drawing color
 *  fill	fill color (or use fill_none)
 *  pattern	choose from patterns above including pattern_solid
 */
function drawCircle(ctx, center, radius, color, fill, pattern)
{
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)  // NB: some browsers (IE<11) don't have setLineDash
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	ctx.context.arc(ctx.offsetx+center.x*ctx.fscale,
					ctx.offsety-center.y*ctx.fscale,
					radius*ctx.fscale,0,2*Math.PI);
	if (fill) {
		ctx.context.fillStyle = fill;
		ctx.context.fill();
	}
	ctx.context.stroke();
	ctx.context.restore();
}

/*
 * Draw a radial line at an angle from the given x,y starting point.
 * The angle is in degrees and we interpret it as clockwise from
 * straight up.  We could let the canvas do the rotation, but since
 * we are doing so much trig anyway, just calculate it.
 *
 *	ctx		drawing context (from makeDrawingContext() above)
 *	center	center point
 * 	angleDeg	angle in degrees (up is zero)
 *	length	length relative to flywheel radius in the ctx
 *	color	drawing color
 *  pattern	choose from patterns above including pattern_solid
 */
function drawRadialLine(ctx, center, angleDeg, length, color, pattern)
{
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	ctx.context.moveTo(ctx.offsetx+center.x*ctx.fscale,
					   ctx.offsety-center.y*ctx.fscale);
	// rotate the endpoint of a vertical (x=0) line going up (y=length)
	var dest = rotate(toPoint(0, length), angleDeg);
	// subtract y to go up because canvas has 0,0 in the upper right
	ctx.context.lineTo(ctx.offsetx+(center.x+dest.x)*ctx.fscale,
					   ctx.offsety-(center.y+dest.y)*ctx.fscale);
	ctx.context.stroke();
	ctx.context.restore();
}


/*
 * Draw a line with color and pattern
 *
  *	ctx		drawing context (from makeDrawingContext() above)
 *	start	start point
 * 	end		end point
 *	color	drawing color
 *  pattern	choose from patterns above including pattern_solid
 */
function drawLine(ctx, start, end, color, pattern)
{
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	ctx.context.moveTo(ctx.offsetx+start.x*ctx.fscale,
					   ctx.offsety-start.y*ctx.fscale);
	ctx.context.lineTo(ctx.offsetx+end.x*ctx.fscale,
					   ctx.offsety-end.y*ctx.fscale);
	ctx.context.stroke();
	ctx.context.restore();
}

/*
 * Draw an arc
 * The start/end angles are in degrees where 0 is straight up.
 *
 *	ctx		drawing context (from makeDrawingContext() above)
 *	center	center point
 *  radius	arc radius
 * 	start	start angle in degrees (up is zero)
 *	end		end angle
 *	color	drawing color
 *  pattern	choose from patterns above including pattern_solid

 */
function drawArc(ctx, center, radius, start, end, color, pattern)
{
	var srad = degreesToRadians(start-90);
	var erad = degreesToRadians(end-90);
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	ctx.context.arc(ctx.offsetx+center.x*ctx.fscale,
					ctx.offsety-center.y*ctx.fscale,
					radius*ctx.fscale, srad, erad);
	ctx.context.stroke();
	ctx.context.restore();
}

/* Same as drawRadialLine, except now drawing a dimension line.
 * This means adding arrowheads and a dimension label.
 * The labelpos is the percent of the way from start to end for the
 * center of the label.
 */
function drawRadialDim(
	ctx,		// drawing context (from makeDrawingContext() above)
	center,		// center point
	angleDeg,	// angle of dimension line
	startlen,	// start of line by length (doesn't have to start at center)
	length,		// length of dimension line
	label,		// label text 
	labelpos,	// position of label as percentage along drawn line
	color,		// color of line
	pattern)	// choose from patterns above including pattern_solid
{
	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	
	// We will draw a "horizontal" line and let canvas do the rotating for us.
	// We use horizontal because that is how text is drawn.  This makes it a bit
	// more complicated because we must interpret angleDeg=0 as "up".
	// Since we want horizontal, we'll just subtract 90 degrees.
	ctx.context.translate(ctx.offsetx+center.x*ctx.fscale,
						  ctx.offsety-center.y*ctx.fscale);	// Now 0,0 is the center.
	ctx.context.rotate(degreesToRadians(angleDeg-90));

	// Adjust lengths for scale.
	startlen *= ctx.fscale;
	length *= ctx.fscale;
	
	// Now we can draw as if we are horizontal, but still must account for fscale
	ctx.context.beginPath();
	ctx.context.moveTo(startlen,0);
	ctx.context.lineTo(length, 0);
	// draw end arrowhead since we are here
	ctx.context.lineTo(length-5, -3);
	ctx.context.moveTo(length, 0);
	ctx.context.lineTo(length-5, 3);
	// draw start arrowhead
	ctx.context.moveTo(startlen,0);
	ctx.context.lineTo(startlen+5, -3);
	ctx.context.moveTo(startlen,0);
	ctx.context.lineTo(startlen+5, 3);
	// Now draw the label in the middle
	var textwidth = ctx.context.measureText(label).width;
	ctx.context.fillStyle = color;
	ctx.context.fillText(label, startlen+((length-startlen)*labelpos)-(textwidth/2), -3);
	ctx.context.stroke();
	ctx.context.restore();
}



/* This draws an angle dimension line.
 *
 * x,y			Center point of angle
 * start, end	Start/end of angle in degrees with 0 as up.
 * length		Length of dimension lines
 * label		The label to draw.  Probably end - start :)
 * labelpos		The percentage up the dimension lines to draw the
 *				dimension arc and label.
 * context, color and pattern define drawing context to use.
 */
function drawAngDim(
	ctx,		// drawing context (from makeDrawingContext() above)
	center,		// center point
	start,		// start angle
	end,		// end angle
	length,		// length of dimension lines
	label,		// label text 
	labelpos,	// position of label as percentage along drawn lines
	color,		// color of line
	pattern)	// choose from patterns above including pattern_solid
{
	var srad = degreesToRadians(start-90);
	var erad = degreesToRadians(end-90);
	var sdim = rotate(toPoint(0, length), start);
	var edim = rotate(toPoint(0, length), end);

	ctx.context.save();
	ctx.context.strokeStyle = color;
	if (pattern && ctx.context.setLineDash)
		ctx.context.setLineDash(pattern);
	ctx.context.beginPath();
	// Draw dimension lines first.
	ctx.context.moveTo(ctx.offsetx+center.x*ctx.fscale,
					   ctx.offsety-center.y*ctx.fscale);
	ctx.context.lineTo(ctx.offsetx+(center.x+sdim.x)*ctx.fscale,
					   ctx.offsety-(center.y+sdim.y)*ctx.fscale);
	ctx.context.moveTo(ctx.offsetx+center.x*ctx.fscale,
					   ctx.offsety-center.y*ctx.fscale);
	ctx.context.lineTo(ctx.offsetx+(center.x+edim.x)*ctx.fscale,
					   ctx.offsety-(center.y+edim.y)*ctx.fscale);
	ctx.context.stroke();
	ctx.context.beginPath();
	// The arc.  Not bothering with arrow heads.
	ctx.context.arc(ctx.offsetx+center.x*ctx.fscale,
					ctx.offsety-center.y*ctx.fscale,
					(length*labelpos)*ctx.fscale,srad,erad);
	ctx.context.stroke();

	// Now draw the label.  We center this on the arc and want it rotated to
	// match the arc.  Let the canvas do the rotation.  Remember up is 0 deg
	// so I need to subtract 90 to get that.  HOWEVER, we want the text 90
	// degrees from the angle anyway, so it works out without this!  Sweet.
	ctx.context.translate(ctx.offsetx+center.x*ctx.fscale,
						  ctx.offsety-center.y*ctx.fscale); // Now 0,0 is the center.
	ctx.context.rotate(degreesToRadians((start+end)/2));	// midway angle
	ctx.context.fillStyle = color;
	var textwidth = ctx.context.measureText(label).width;
	var textheight = ctx.context.measureText(label).height;
	ctx.context.fillText(label, -textwidth/2, -(length*ctx.fscale)*labelpos-5);

	ctx.context.restore();
}



/* Calculate Flywheel data
 * =======================
 *
 * This function doesn't draw anything.  It calculates all the useful
 * coordinates and angles for the flywheel.
 *
 * The input arguments are documented in the function declaration.  These
 * come from the web page user interface.  Angles are specified here in
 * degrees.  Length units are unspecified, but are assumed to be consistant
 * (i.e. use all inches or mm for lengths)
 *
 * The outputs are documented at the end of the function where an object
 * containing all this data is returned.
 *
 * Note that the coordinate system for these calculations is what you'd use
 * in a math graph.  That is, 0,0 is the center of the flywheel.  The first
 * spoke will be created straight up, and angles in the output will be measured
 * in a clockwise direction, in degrees, from this vertical spoke.
 *
 * Note also that some internal calculations within this function use a
 * rotated and transformed (shifted) coordinate system.  I'll try to document
 * this so it can be understood.
 */
function calculateFlywheel(
	units,				// mm or in.  Not really used here, but saved.
	numSpokes,			// 2..something reasonable.
	flywheelRadius,		// outside of flywheel in units (mm, inches, etc)
	rimRadius,			// inside of flywheel rim
	hubRadius,			// outside of hub
	shaftRadius,		// shaft size (note: radius, not diameter)
	innerHoleRadius,	// hole size used in the web near the shaft
	innerHoleAngle,		// angle of inner hole clockwise from vertical
	innerHoleDistance,	// radius of inner hole from the center
	outerHoleRadius,	// hole size used in the web near the rim
	outerHoleAngle,		// angle of outer hole clockwise from vertical
	outerHoleDistance,	// radius of outer hole from the center
	curveAngle			// twist angle of outer rim for curved spokes
) {

	// Return an object with a pile of fields, including the inputs
	var fly = {
		units:	units,
		numSpokes: numSpokes,
		spokeAngle: 360 / numSpokes,
		spokeBisect: 180 / numSpokes,
		flywheelRadius: flywheelRadius,
		flywheelDiameter: flywheelRadius*2,
		rimRadius: rimRadius,
		rimDiameter: rimRadius*2,
		hubRadius: hubRadius,
		hubDiameter:hubRadius*2,
		shaftRadius: shaftRadius,
		shaftDiameter: shaftRadius*2,
		innerHoleAngle: innerHoleAngle,
		innerHoleRadius: innerHoleRadius,
		innerHoleDiameter: innerHoleRadius*2,
		innerHoleDistance: innerHoleDistance,
		outerHoleAngle: outerHoleAngle,
		outerHoleRadius: outerHoleRadius,
		outerHoleDiameter: outerHoleRadius*2,
		outerHoleDistance: outerHoleDistance,
		curveAngle: curveAngle
	};
	
	// Now calculate for spoke #0 (and web clockwise from this spoke)
	// All other spokes can use this data provided it is rotated by
	// n*fly.spokeAngle, where n is the spoke #.

	// Calculate angles and coords of the 4 holes
	// Note that we take a point on the Y-axis and rotate it to trivially calculate these.
	// The left angle is negative.  This isn't surprising, but code using this data is
	// usually working with the web cutout to the right of a spoke.  Therefore,
	// fly.spokeAngle + fly.leftInnerAngle, for example, is a common calculation when
	// working with a web.  The left side of the web is the right side of a spoke, and
	// the right side of the web cutout is the left side of the *next* spoke.  This can
	// be confusing.  This data structure represents a spoke, so remember that right/left
	// are relative to the spoke, not the web.
	var inpoint = toPoint(0,innerHoleDistance);
	var outpoint = toPoint(0,outerHoleDistance);
	fly.rightInnerAngle = innerHoleAngle;
	fly.rightInnerCenter = rotate(inpoint, fly.rightInnerAngle);
	fly.rightOuterAngle = outerHoleAngle + curveAngle;		// Outer hole is twisted for curved spokes
	fly.rightOuterCenter = rotate(outpoint, fly.rightOuterAngle);
	fly.leftInnerAngle = -innerHoleAngle;
	fly.leftInnerCenter = rotate(inpoint, fly.leftInnerAngle);
	fly.leftOuterAngle = -outerHoleAngle + curveAngle;		// Outer hole is twisted for curved spokes
	fly.leftOuterCenter = rotate(outpoint, fly.leftOuterAngle);

	fly.outerArc = fly.outerHoleDistance + fly.outerHoleRadius;
	fly.innerArc = fly.innerHoleDistance - fly.innerHoleRadius;

	// Calculate drawing data for the web cutout.
	// This web is to the right (clockwise) of the spoke.
	// Therefore, some numbers are relative to the next spoke which is at fly.spokeAngle.
	
	// Calculate the finished edge outer arc.
	fly.edgeOuterArc = {};  // new object.
	fly.edgeOuterArc.radius = outerHoleDistance + outerHoleRadius;
	fly.edgeOuterArc.startAngle = fly.rightOuterAngle;
	fly.edgeOuterArc.endAngle = fly.spokeAngle + fly.leftOuterAngle;
	
	// Calculate the finished edge inner arc.
	fly.edgeInnerArc = {};  // new object.
	fly.edgeInnerArc.radius = innerHoleDistance - innerHoleRadius;
	fly.edgeInnerArc.startAngle = fly.rightInnerAngle;
	fly.edgeInnerArc.endAngle = fly.spokeAngle + fly.leftInnerAngle;
	// We will calculate 4 drawing arcs for the remaining edges of the
	// holes that were drilled.  These aren't useful on the mill, but
	// are useful when drawing the flywheel.  We already have recorded
	// the arc centers and radii as center/radius of each hole, so all
	// we need to record now is the start/end angles of each arc.
	
	// Create the objects first.  They have start/end angles.
	// The centers and radii are properties of the holes.
	// The values are dependent on curve vs. straight so will fill in below.
	fly.rightOuterHoleArc = {};
	fly.rightInnerHoleArc = {};
	fly.leftOuterHoleArc = {};
	fly.leftInnerHoleArc = {};

	if (fly.curveAngle) {
		// Curved spokes.
		//
		// Note that a curveAngle cannot be negative.
		// The spokes always curve in the clockwise direction.
		//
		// This produces the following calculated values for cutting curved spokes:
		//
		//		fly.curveAngle				input data (> 0 indicated curved spokes)
		//		fly.curveRadius				all cuts are this radius
		//		fly.curveSpokeCenter		point (x,y)  center of arc for centerline of spoke
		//		fly.curveSpokeStartAngle
		//		fly.curveSpokeEndAngle
		//		fly.curveCutRightCenter		point (x,y)
		//		fly.curveCutRightStartAngle
		//		fly.curveCutRightEndAngle
		//		fly.curveCutLeftCenter		point (x,y)
		//		fly.curveCutLeftStartAngle
		//		fly.curveCutLeftEndAngle
		//		fly.curveSpokeCenterlineEndAngle for bounding the centerline

		// Start by forming an arc from 3 points:
		//   A: The midpoint of the line between the right outer hole center
		//		and the left outer hole center of the previous spoke
		//   B: The midpoint of the line between the right inner hole center
		// 		and the left inner hole center of the previous spoke
		//   C: The center of the flywheel (this is "adjusted" to the left).
		// This makes a nicely shaped spoke.  The radius of this arc is what
		// we really need.  When we calculate the arcs for cutting, we'll use
		// this radius to compute an arc that is tangent to the inner/outer
		// holes so we get a nice transition.
		
		var ptA = midpoint(fly.leftOuterCenter, fly.rightOuterCenter);
		var ptB = midpoint(fly.leftInnerCenter, fly.rightInnerCenter);
		// Point C could be 0,0 which is always the hub center, but we "adjust" it to the left (negative).
		// We adjust point C to the right of the center of the hub.  We use the curveangle as a ratio of the spokeAngle.
		// At the full spokeAngle we will shift to the right of the center 1/2 of the innerHoleDistance.  This can go further
		// if the curveangle is allowed to exceed the spokeAngle.  We don't change Y -- it stays at zero.
		var ptC = toPoint(-(fly.innerHoleDistance/2)*(fly.curveAngle/fly.spokeAngle), 0);
				
		// Now calculate the radius given these 3 points.
		//
		// This arc will form the centerline of the spoke.  It has a center, radius, and start/end angle
		//
		// There are a couple ways to do this.  You can calculate perpendicular
		// lines off the two line segments beteen the three points and where
		// these perpendicular lines intersect is the center.
		//
		// The other way is to use the equation of a circle:
		//    (x-h)^2 + (y-k)^2 = r^2    (where ^2 represents "squared")
		// here we have 3 sets of x,y values, but h, k and r are unknown.
		// Since we have 3 sets, and 3 variables, we can solve.   This
		// produces a lot of algebra rearranging that I won't document here.
		// See http://2000clicks.com/mathhelp/GeometryConicSectionCircleEquationGivenThreePoints.aspx
		// and I'll stick to their variable names so it makes sense to the reader.
		var a=ptA.x, b=ptA.y, c=ptB.x, d=ptB.y, e=ptC.x, f=ptC.y;
		var h, k, r;
		h = (1/2)*((a*a+b*b)*(f-d) + (c*c+d*d)*(b-f) + (e*e+f*f)*(d-b)) / (a*(f-d) + c*(b-f) + e*(d-b));
		k = (1/2)*((a*a+b*b)*(e-c) + (c*c+d*d)*(a-e) + (e*e+f*f)*(c-a)) / (b*(e-c) + d*(a-e) + f*(c-a));
		r = Math.sqrt((a-h)*(a-h) + (b-k)*(b-k));
		
		fly.curveRadius = r;
		fly.curveSpokeCenter = toPoint(h,k);
		fly.curveSpokeStartAngle = angle(fly.curveSpokeCenter, ptC);
		fly.curveSpokeEndAngle = angle(fly.curveSpokeCenter, ptA);
		
		// Now we have our radius.  We'll use it to calculate the center
		// point for the two arcs we need (two cut sides of the spoke).
		//
		// We want this arc to be tangent to the inner/outer hole edges.
		// The observation is that the radius of the arc goes through the
		// center of each of these circles.
		//
		// We also know the radius of both inner and outer holes, so we
		// can subtract each of those from the arc radius to give us r1 and r2.
		// These are lengths of two sides of a triangle (two sides of the "pie"
		// that is formed by the arc.  The third side's length is the distance
		// between centers of the inner/outer holes.  Call this distance d.
		//
		//							  o (0,d) outer hole center
		//					          |\
		//					          | \
		//					          |  \r2
		//					          |   \
		//					         b|    \
		//					          |   h \
		//					          |------+ (x,y)
		//					          |     /
		//					         a|   / r1
		//                            | /
		//			------------------O--------------------- (temp rotated X,Y axes)
		//                            | (0,0) inner hole center
		//
		
		// Do these calculations for the right side first.
		// Here, the curve radius must extend from (x,y) to the other side of both inner
		// and outer holes.  So if r is this full radius we must subtrace each hole's
		// radius to get r1 and r2.
		//
		// Let's have this triangle unrotated with the outer hole center vertex
		// positioned at 0,0.  We calculated the base length as d, so the inner
		// hole vertex on the left is d,0.   Drop a line perpendicular to the
		// base and we get two left triangles.  The lengths a, b, and h are
		// unknown.  We know d=a+b, so let's find them.  When we do, we can
		// use (a,h) to represent x,y.  All we need to do is rotate the triangle
		// and then shift it by the original coords for the right vertex.
		var d = distance(fly.rightInnerCenter, fly.rightOuterCenter);
		var r1 = fly.curveRadius - fly.innerHoleRadius;
		var r2 = fly.curveRadius - fly.outerHoleRadius;
		var a = (d*d + r1*r1 - r2*r2) / (2*d);
		var h = Math.sqrt(r1*r1 - a*a);	// Pythagorean Theorem to calc the 3rd side.

		// Our point x,y above is really (h,a).  But we need to rotate it back
		// and shift it properly because it was relative to the inner hole center.
		var ang = angle(fly.rightInnerCenter, fly.rightOuterCenter);
		var xy = rotate(toPoint(h,a), ang);
		fly.curveCutRightCenter = addPoints(xy, fly.rightInnerCenter);
		fly.curveCutRightStartAngle = angle(fly.curveCutRightCenter, fly.rightInnerCenter);
		fly.curveCutRightEndAngle = angle(fly.curveCutRightCenter, fly.rightOuterCenter);
		
		// Now do calculations for the left side.
		// The left side is the "far" side of spoke, and therefore goes to the near side
		// of the inner and outer hole radii.  Other than a sign change, it is the same math.

		// The other side of the spoke is almost the same.
		// However, we use the prev holes, of course, and we must ADD to get
		// r1, r2 since we are on the near side of the holes.
		var d = distance(fly.leftInnerCenter, fly.leftOuterCenter);
		var r1 = fly.curveRadius + fly.innerHoleRadius;
		var r2 = fly.curveRadius + fly.outerHoleRadius;
		var a = (d*d + r1*r1 - r2*r2) / (2*d);
		var h = Math.sqrt(r1*r1 - a*a); // Pythagorean Theorem to calc the 3rd side.

		var ang = angle(fly.leftInnerCenter, fly.leftOuterCenter);
		var xy = rotate(toPoint(h,a), ang);
		fly.curveCutLeftCenter = addPoints(xy, fly.leftInnerCenter);
		fly.curveCutLeftStartAngle = angle(fly.curveCutLeftCenter, fly.leftInnerCenter);
		fly.curveCutLeftEndAngle = angle(fly.curveCutLeftCenter, fly.leftOuterCenter);
		
		// Next calculate the length of the centerline for drawing purposes
		//
		// Since this is a curved spoke, we really need an end-arc angle so it extends 5% beyond
		// edge of the flywheel (as with the straight spoke where the math is trivial)
		// To do this, we calculate the intersection of the circle 5% bigger than the flywheel
		// and the circle that represents the centerline.
		// See http://paulbourke.net/geometry/circlesphere/ for an explanation.  P0 represents the
		// center of the flywheel (always 0,0 which is nice), and P1 represents the center of the
		// centerline arc (fly.curveSpokeCenter).  We need to calculate P2, and this leads to P3.
		// See the webpage.  The math here tries to reflect that page is much as possible.
		//
		// We use 5% beyond rim because the centerline really can arc around and miss the flywheel
		// outer edge for heavy rotations.  We could check if d < |r1-r0| or if h is NaN.  This might
		// be an indicator that the curve is too sharp and unmachinable.
		//
		var P0 = toPoint(0,0);
		var P1 = fly.curveSpokeCenter;
		var d = distance(P0, P1);
		var r0 = fly.rimRadius*1.05;		// Use rim to make sure it fits.
		var r1 = fly.curveRadius;
		var a = (r0*r0 - r1*r1 + d*d)/(2*d);	// distance from P0 to P2 heading on the slope toward P1.
		var h = Math.sqrt(r0*r0 - a*a);			// Pythagorean formula to get 3rd side of the triangle		
		var x2 = (a * P1.x)/d;					// simple because P0 (x0,y0) is 0,0 center of flywheel
		var y2 = (a * P1.y)/d;
		var x3 = x2 - (h * P1.y)/d;				// also simple due to 0,0
		var y3 = y2 + (h * P1.x)/d;
		fly.curveSpokeCenterlineEndAngle = angle(fly.curveSpokeCenter, toPoint(x3,y3));

		// Finally, fill in the drawing arcs.  The objects have been created earlier.
		fly.rightOuterHoleArc.startAngle = fly.curveCutRightEndAngle;
		fly.rightOuterHoleArc.endAngle = fly.edgeOuterArc.startAngle;
		fly.rightInnerHoleArc.startAngle = fly.edgeInnerArc.startAngle + 180;
		fly.rightInnerHoleArc.endAngle = fly.curveCutRightStartAngle;
		fly.leftOuterHoleArc.startAngle = fly.edgeOuterArc.endAngle - fly.spokeAngle;
		fly.leftOuterHoleArc.endAngle = fly.curveCutLeftEndAngle - 180;
		fly.leftInnerHoleArc.startAngle = fly.curveCutLeftStartAngle + 180;
		fly.leftInnerHoleArc.endAngle = fly.edgeInnerArc.endAngle - fly.spokeAngle - 180;
		
		// Calculate thickness of spoke at inner and outer holes.
		//
		// Do the outer hole first.
		// We make the observation that the thickness of the spoke near the outer hole is the distance
		// between right/left arcs along the radial line from the center of the right cutline arc to the left
		// outer hole.  We find the point where each arc intersects this line, then compute the distance between them..
		//
		// First calculate the point along the edge of the left outer hole that is on the "inside" aligned with the
		// radial line to the center of the left cutline arc.  An easy way to calculate this is to take (0,r), where
		// r is the radius of the outer hole.  This point is relative to the center of the hole.  Now rotate the point
		// using the angle of the line from the center of this hole to the center of the arc.  This is already
		// calculated as fly.curveCutLeftEndAngle. Finally, this coordinate is relative to the center of the hole,
		// so add the center of the hole to get the final coordinates.  It's easier than it sounds.
		var edgePt = toPoint(0,fly.outerHoleRadius);
		var rotPt = rotate(edgePt, fly.curveCutLeftEndAngle-180);
		fly.outerLeftSpokeThicknessPoint = addPoints(fly.leftOuterCenter, rotPt);
		fly.outerSpokeThickness = distance(fly.curveCutRightCenter, fly.outerLeftSpokeThicknessPoint) - fly.curveRadius;
		// Calculate the outer right thickness point for debug.
		var ang = angle(fly.curveCutRightCenter, fly.outerLeftSpokeThicknessPoint);
		var edgePt = toPoint(0,fly.curveRadius);
		var rotPt = rotate(edgePt, ang);
		fly.outerRightSpokeThicknessPoint = addPoints(fly.curveCutRightCenter, rotPt);
				
		// Now do the same for the inner spoke thickness.
		// This time use the right cut arc to find the right thickness point first.
		// Then find the left point using the left cut arc center and radius.
		var edgePt = toPoint(0,fly.innerHoleRadius);
		var rotPt = rotate(edgePt, fly.curveCutRightStartAngle);
		fly.innerRightSpokeThicknessPoint = addPoints(fly.rightInnerCenter, rotPt);
		fly.innerSpokeThickness = fly.curveRadius - distance(fly.curveCutLeftCenter, fly.innerRightSpokeThicknessPoint);
		
		// Calculate position of a location pin.
		// This pin is fixed as 3/16 or 4.8mm depending on the units.
		// The machinist can use a different size hole.  It's the position that matters.
		// We need the diameter here to back it away from the outer arc.
		if (units == "mm") {
			fly.locationPinDiameter = 4.8;		// 4.8 mm dia
		} else {
			fly.locationPinDiameter = 0.188;	// 3/16" dia
		}
		// Place the location pin approximately half way between the outer holes.
		fly.locationPinAngle = fly.spokeBisect + fly.curveAngle;
		fly.locationPinDistance = fly.outerArc - fly.locationPinDiameter;
		// Now rotate the location pin center from vertical.  Note it is inside the outerArc
		// because we use diameter instead of radius to pull it away from the outerArc.
		var edgePt = toPoint(0, fly.locationPinDistance)
		fly.locationPinCenter = rotate(edgePt, fly.locationPinAngle)
		
		// Calculate dimensions needed for the fixture plate.  This includes
		// an example size of the plate as well as the relative positions of the 4
		// key locations on the plate.
		
		// Point A:  The flywheel center (easy, 0,0)
		// Point B:  The location pin position locationPinCenter
		// Point C:  The left spoke radius center.   curveCutLeftCenter
		// Point D:  The right spoke radius center.  curveCutRightCenter
	
		// Figure out the "base point" for the fixture.  Is B, C or D lower?
		// D may be always lower (in Y) than C, but with severe rotation the
		// location pin B can be lowest of all.  Just check them all.
		// The "base point" is one of points A,B,C,D, but we don't track which.
		// The base point is only used for the fixtureAngle calculation below.
		var basePt;
		if (fly.curveCutLeftCenter.y < fly.curveCutRightCenter.y) {
			basePt = fly.curveCutLeftCenter;
		} else {
			basePt = fly.curveCutRightCenter;
		}
		if (fly.locationPinCenter.y < basePt.y) {
			basePt = fly.locationPinCenter;
		}
		
		// Now rotate everything so ptA to basePt is a horizontal line.
		// basePt.x > ptA.x always.  The angle of rotation is usually negative
		// so we need to rotate counter-clockwise -- but not always.
		// We rotate around point A so it will not change coordinates.
		var ptA = toPoint(0,0)
		var ang = 90 - angle(ptA, basePt)
		var ptB = rotate(fly.locationPinCenter, ang)
		var ptC = rotate(fly.curveCutLeftCenter, ang)
		var ptD = rotate(fly.curveCutRightCenter, ang)
		
		// Now estimate a fixture size.  We'll start by using a fraction of the flywheel.
		// The calculation here is the size of the fixture before we add material below and to the left
		// of the flywheel center point.   Use 75% of diameter in X and 50% in Y.  Below we will add
		// 25% below and to the left of the flywheel center.  So the example fixture will be
		// 100%x75% of the flywheel diameter.  Hopefully this will result in nice round numbers
		// under the assumption the flywheel diameter is usually a round number.
		// We also perform bounds checks on the odd chance the milling radius would be too big to
		// fit.  A *very* small curve angle can do this (<15) and might simply be disallowed.
		var recommend = toPoint(fly.flywheelDiameter*0.75, fly.flywheelDiameter*0.50)
		
		// Go through some calculations to expand the fixture plate size in case B, C or D
		// is too far out.  As mentioned earlier, we could bound curveangle so this can't happen.
		
		// Now calculate a bounding box for the points.  The fixture must be bigger than this.
		// We know the baseline is along y=0.  Also x>=0.  So ptA is the bottom left of this box.
		// Find the bound point (upper right)
		var bound = toPoint(ptB.x, ptB.y)			// start with guess that B is it.
		if (ptC.x > bound.x) {
			bound.x = ptC.x
		}
		if (ptD.x > bound.x) {
			bound.x = ptD.x
		}
		if (ptC.y > bound.y) {
			bound.y = ptC.y
		}
		if (ptD.y > bound.y) {
			bound.y = ptD.y
		}
		
		// Add 1/2" or 10mm for working room.  May not be needed, but this isn't much.
		var slack = 0.5;	// inches
		if (fly.units == "mm") {
			slack = 10	// mm
		}
		
		if (bound.x+slack > recommend.x) {
			recommend.x = bound.x+slack
		}
		if (bound.y+slack > recommend.y) {
			recommend.y = bound.y+slack
		}
		// Now add the extra 25% on the other side of the flywheel (negative X and Y).
		var recommendOffset = toPoint(fly.flywheelDiameter*0.25, fly.flywheelDiameter*0.25)
		recommend = addPoints(recommend, recommendOffset)
		
		// Save the fixture data
		fly.fixtureSize = recommend
		fly.fixtureAngle = ang
		fly.fixtureOffset = recommendOffset  // recommended position for ptA
		fly.fixtureA = ptA
		fly.fixtureB = ptB
		fly.fixtureC = ptC
		fly.fixtureD = ptD

		
		// Calculate the inner left thickness point for debug.
		var ang = angle(fly.curveCutLeftCenter, fly.innerRightSpokeThicknessPoint);
		var edgePt = toPoint(0,fly.curveRadius);
		var rotPt = rotate(edgePt, ang);
		fly.innerLeftSpokeThicknessPoint = addPoints(fly.curveCutLeftCenter, rotPt);
			
	} else {
		// Straight spokes.
		//
		// This produces the following calculated values for cutting straight spokes:
		//		fly.rightCutEdgeStart	start point (x,y)
		//		fly.rightCutEdgeEnd		end point (x,y)
		//		fly.rightCutAngle
		//		fly.leftCutEdgeStart	start point (x,y)
		//		fly.leftCutEdgeEnd		end point (x,y)
		//		fly.leftCutAngle
		//		fly.spokeCenterlineRadius  length of radius for drawing the centerlines of spokes
		
		// The calculation is relative to the line between the inner hole center and outer hole center.
		// This is done for both left and right cut lines.
		//
		// The following very crude artwork shows the right cutline of a spoke
		// The right cutline connects with the "left" edges between outer and inner holes.
		// We work in rotated axes such that 0,0 represents the center of the inner hole,
		// and (0,d) represents the center of the outer hole.  The value d is the distance
		// between inner/outer hole centers (easily calculated).
		//
		//							 /o (outer hole center)
		//					        / |
		//					       /  |
		//					      /   |
		//					     /    |  (inner hole center)
		//			-------------+----O--------------------- (temp rotated X,Y axes)
		//                            |
		// We can trivially calculate the endpoints of the cutline in this space which has
		// been shifted and rotated.  If the inner center hole radius is i, and the outer
		// center hole radius is o, the endpoints of this line go from (-i,0) to (-o,d).
		//
		// To produce final coordinates, these two endpoints need to be rotated back to match
		// the angle of the line that connects the centers of the holes.  Finally, the result
		// must be shifted by the coordinates of the inner center hole because referred to that
		// as 0,0 when doing the math.  That is, we did "offset" math relative to that coordinate.
		//
		// Finally, once we have the endpoints of a cutline, we can calculate its angle.  We
		// fix the number of digits in this angle so it comes out consistently in calculations.
		// NOTE:  angdigits is set to 1 so we round angles to ten's of a degree.  A tenth of a
		// degree is 6 minutes, so note that all angles reported have zero seconds and are a
		// multiple of 6 minutes.
		// NOTE:  rounding to 0.1 degrees produces an error of as much as 0.05 degrees.
		// TAN(0.05) = 0.00087, so over a span of 10 inches(mm) we have an error of 0.0087 inches(mm).
		// Most cuts are on the order of an inch so less than 0.0008 or maybe 25x for mm.  For very
		// large flywheels this could be noticed, but barely.
		
		// Calculate the cutline to the right of the spoke
		var rightHoleCenterAngle = angle(fly.rightInnerCenter, fly.rightOuterCenter);
		var rightHoleDistance = distance(fly.rightInnerCenter, fly.rightOuterCenter);
		var rightStart = rotate(toPoint(-fly.innerHoleRadius, 0), rightHoleCenterAngle);
		var rightEnd = rotate(toPoint(-fly.outerHoleRadius, rightHoleDistance), rightHoleCenterAngle);
		fly.rightCutEdgeStart = addPoints(fly.rightInnerCenter, rightStart);
		fly.rightCutEdgeEnd = addPoints(fly.rightInnerCenter, rightEnd);
		fly.rightCutAngle = angle(fly.rightCutEdgeStart, fly.rightCutEdgeEnd).toFixed(angdigits);
		
		// Calculate the cutline to the left of the spoke
		var leftHoleCenterAngle = angle(fly.leftInnerCenter, fly.leftOuterCenter);
		var leftHoleDistance = distance(fly.leftInnerCenter, fly.leftOuterCenter);
		var leftStart = rotate(toPoint(fly.innerHoleRadius, 0), leftHoleCenterAngle);
		var leftEnd = rotate(toPoint(fly.outerHoleRadius, leftHoleDistance), leftHoleCenterAngle);
		fly.leftCutEdgeStart = addPoints(fly.leftInnerCenter, leftStart);
		fly.leftCutEdgeEnd = addPoints(fly.leftInnerCenter, leftEnd);
		fly.leftCutAngle = angle(fly.leftCutEdgeStart, fly.leftCutEdgeEnd).toFixed(angdigits);
		
		// This is a bound for the spoke centerlines. We use 5% beyond the edge.
		fly.spokeCenterlineRadius = fly.flywheelRadius * 1.05;
		
		// Finally, fill in the drawing arcs.  The objects have been created earlier.
		fly.rightOuterHoleArc.startAngle = rightHoleCenterAngle - 90;
		fly.rightOuterHoleArc.endAngle = fly.rightOuterAngle;
		fly.rightInnerHoleArc.startAngle = fly.rightInnerAngle - 180;
		fly.rightInnerHoleArc.endAngle = rightHoleCenterAngle - 90 - 360;
		fly.leftOuterHoleArc.startAngle = fly.leftOuterAngle;
		fly.leftOuterHoleArc.endAngle = leftHoleCenterAngle - 270;
		fly.leftInnerHoleArc.startAngle = leftHoleCenterAngle + 90;
		fly.leftInnerHoleArc.endAngle = fly.leftInnerAngle - 180;
		
		// Calculate thickness of spoke at inner and outer holes.
		// This is easy with spoke zero because Y is fixed.  That is, inner/outer holes
		// are horizontally aligned and also equidistant from the spoke.
		// So just use the X dimension less the radius of the hole and double it.
		fly.innerSpokeThickness = (fly.rightInnerCenter.x - fly.innerHoleRadius)*2;
		fly.outerSpokeThickness = (fly.rightOuterCenter.x - fly.outerHoleRadius)*2;
		
		// Calculate cutting angles and offset position for the RT.
		fly.cutRotationAngle = 360 - fly.rightCutAngle;
		if (fly.cutRotationAngle == 360)
			fly.cutRotationAngle = 0;	// more sane
		fly.returnRotationAngle = 360 - fly.cutRotationAngle;
		if (fly.returnRotationAngle == 360)
			fly.returnRotationAngle = 0;	// more sane
		fly.cutPosition = rotate(fly.rightCutEdgeStart, fly.cutRotationAngle);
	}

	return fly;
}

/*
 * Draw the Flywheel.
 *
 */
function drawFlywheelDemo(canvas, fly) {

	var flyctx = makeDrawingContext(canvas, fly.flywheelRadius);
	var center = toPoint(0,0);

	// Assigning to canvas.width will clear it
	canvas.width = canvas.width;

	// Draw the flywheel
	//
	// Shade the flywheel light gray, but fill in the web (out to the rim)
	// with a white circle.  The hub is also white, but the shaft is dark gray.

	drawCircle(flyctx, center, fly.flywheelRadius, "black", "lightgray", pattern_solid);
	drawCircle(flyctx, center, fly.rimRadius, "black", "white", pattern_solid);
	drawCircle(flyctx, center, fly.hubRadius, "black", "white", pattern_solid);
	drawCircle(flyctx, center, fly.shaftRadius, "black", "gray", pattern_solid);
	
	// Draw the radius lines for inner/outer hole pattern
	drawCircle(flyctx, center, fly.innerHoleDistance, "red", fill_none, pattern_dot);
	drawCircle(flyctx, center, fly.outerHoleDistance, "red", fill_none, pattern_dot);
	
	if (fly.curveAngle) {
		//drawCircle(flyctx, fly.outerLeftSpokeThicknessPoint, 2/flyctx.fscale, "green", "green", pattern_solid);
		//drawCircle(flyctx, fly.outerRightSpokeThicknessPoint, 2/flyctx.fscale, "blue", "blue", pattern_solid);
		//drawCircle(flyctx, fly.innerLeftSpokeThicknessPoint, 2/flyctx.fscale, "green", "green", pattern_solid);
		//drawCircle(flyctx, fly.innerRightSpokeThicknessPoint, 2/flyctx.fscale, "blue", "blue", pattern_solid);
		// drawCircle(flyctx, fly.curveSpokeCenter, 2/flyctx.fscale, "black", "black", pattern_solid);

		drawCircle(flyctx, fly.curveCutLeftCenter, 2/flyctx.fscale, "green", "green", pattern_solid);
		drawCircle(flyctx, fly.curveCutRightCenter, 2/flyctx.fscale, "blue", "blue", pattern_solid);

		drawCircle(flyctx, fly.locationPinCenter, 1/flyctx.fscale, "black", "black", pattern_solid);
		drawCircle(flyctx, center, 1/flyctx.fscale, "black", "black", pattern_solid);
	}

	// Loop through the spokes and draw stuff using the spkinfo.
	// Note that the info for spoke position N refers to detail clockwise
	// from the spoke.  Position N=0 is straight up.
	var thisangle = 0;
	for (var spk=0; spk < fly.numSpokes; spk++) {		
		// Draw the 4 holes
		var rightInnerCenter = rotate(fly.rightInnerCenter, thisangle);
		var rightOuterCenter = rotate(fly.rightOuterCenter, thisangle);
		var leftInnerCenter = rotate(fly.leftInnerCenter, thisangle);
		var leftOuterCenter = rotate(fly.leftOuterCenter, thisangle);
		// Rather than work with the hole to the left of this spoke, we advance to the
		// left of the *next* spoke so we draw only in a clockwise fashion.
		var nextleftInnerCenter = rotate(fly.leftInnerCenter, thisangle + fly.spokeAngle);
		var nextleftOuterCenter = rotate(fly.leftOuterCenter, thisangle + fly.spokeAngle);

		drawCircle(flyctx, rightInnerCenter, fly.innerHoleRadius, "lightgray", fill_none, pattern_solid);
		drawCircle(flyctx, rightOuterCenter, fly.outerHoleRadius, "lightgray", fill_none, pattern_solid);
		drawCircle(flyctx, nextleftInnerCenter, fly.innerHoleRadius, "lightgray", fill_none, pattern_solid);
		drawCircle(flyctx, nextleftOuterCenter, fly.outerHoleRadius, "lightgray", fill_none, pattern_solid);

		// Draw the outer edge arc
		drawArc(flyctx, center, fly.edgeOuterArc.radius,
					fly.edgeOuterArc.startAngle + thisangle,
					fly.edgeOuterArc.endAngle + thisangle,
					"black", pattern_solid);
		// Draw the inner edge arc
		drawArc(flyctx, center, fly.edgeInnerArc.radius,
					fly.edgeInnerArc.startAngle + thisangle,
					fly.edgeInnerArc.endAngle + thisangle,
					"black", pattern_solid);

		if (fly.curveAngle) {
			// Curve spoke drawing.
			
			// Draw spoke centerline.   curveSpokeCenterlineEndAngle was calculated for this purpose
			var curveSpokeCenter = rotate(fly.curveSpokeCenter, thisangle);
			drawArc(flyctx, curveSpokeCenter, fly.curveRadius,
					fly.curveSpokeStartAngle + thisangle, fly.curveSpokeCenterlineEndAngle + thisangle,
					"gray", pattern_dash_dot_dot);

			// Draw right cut arc
			var curveCutRightCenter = rotate(fly.curveCutRightCenter, thisangle);
			drawArc(flyctx, curveCutRightCenter, fly.curveRadius,
					fly.curveCutRightStartAngle + thisangle, fly.curveCutRightEndAngle + thisangle,
					"black", pattern_solid);
					
			// Draw left cut arc
			var curveCutLeftCenter = rotate(fly.curveCutLeftCenter, thisangle);
			drawArc(flyctx, curveCutLeftCenter, fly.curveRadius,
					fly.curveCutLeftStartAngle + thisangle, fly.curveCutLeftEndAngle + thisangle,
					"black", pattern_solid)

			var pinCenter = rotate(fly.locationPinCenter, thisangle);
			drawCircle(flyctx, pinCenter, fly.locationPinDiameter/2, "lightgray", fill_none, pattern_solid);


		} else {
			// Straight spoke drawing.
			
			// Draw spoke centerline
			drawRadialLine(flyctx, center, thisangle,
							fly.spokeCenterlineRadius,   		// radius + 5%
							"gray", pattern_dash_dot_dot);

			// Draw right/left cut lines
			var rightCutEdgeStart = rotate(fly.rightCutEdgeStart, thisangle);
			var rightCutEdgeEnd = rotate(fly.rightCutEdgeEnd, thisangle);
			drawLine(flyctx, rightCutEdgeStart, rightCutEdgeEnd, "black", pattern_solid);
			
			var leftCutEdgeStart = rotate(fly.leftCutEdgeStart, thisangle);
			var leftCutEdgeEnd = rotate(fly.leftCutEdgeEnd, thisangle);
			drawLine(flyctx, leftCutEdgeStart, leftCutEdgeEnd, "black", pattern_solid);
		}

		// Draw arcs to connect cut lines with cut edge arcs
		// This makes the drawing look nice.  The inner/outer holes
		// are drilled when milling and this forms these arcs as the
		// inside web is cut away.
		drawArc(flyctx, rightOuterCenter, fly.outerHoleRadius,
				fly.rightOuterHoleArc.startAngle + thisangle,
				fly.rightOuterHoleArc.endAngle + thisangle,
				"black", pattern_solid);
		drawArc(flyctx, rightInnerCenter, fly.innerHoleRadius,
				fly.rightInnerHoleArc.startAngle + thisangle,
				fly.rightInnerHoleArc.endAngle + thisangle,
				"black", pattern_solid);
		drawArc(flyctx, nextleftOuterCenter, fly.outerHoleRadius,
				fly.leftOuterHoleArc.startAngle + thisangle + fly.spokeAngle,
				fly.leftOuterHoleArc.endAngle + thisangle + fly.spokeAngle,
				"black", pattern_solid);
		drawArc(flyctx, nextleftInnerCenter, fly.innerHoleRadius,
				fly.leftInnerHoleArc.startAngle + thisangle + fly.spokeAngle,
				fly.leftInnerHoleArc.endAngle + thisangle + fly.spokeAngle,
				"green", pattern_solid);

		// Advance to next spoke angle for next iteration
		thisangle += fly.spokeAngle;
	}
}


/*
 * Draw the Flywheel dimension markings.
 * For now we draw the flywheel demo first, dim it, then draw over it.
 *
 */
function drawFlywheelDims(canvas, fly) {

	var flyctx = makeDrawingContext(canvas, fly.flywheelRadius);
	var center = toPoint(0,0);

	/* First, draw dim demo by drawing a transparent white rectangle over it.  Cool, no? :) */
	drawFlywheelDemo(canvas, fly)
	flyctx.context.save();
	flyctx.context.fillStyle="white";
	flyctx.context.globalAlpha="0.65";
	flyctx.context.fillRect(0,0,canvas.width,canvas.height);
	flyctx.context.restore();

	// Draw the web cutout holes for the first web only.
	// The demo drew all of them very lightly since we greyed it.  This highlights 
	// for dimensions we are adding here.
	drawCircle(flyctx, fly.rightInnerCenter, fly.innerHoleRadius, "black", fill_none, pattern_solid);
	drawCircle(flyctx, rotate(fly.leftInnerCenter, fly.spokeAngle), fly.innerHoleRadius, "black", fill_none, pattern_solid);
	drawCircle(flyctx, fly.rightOuterCenter, fly.outerHoleRadius, "black", fill_none, pattern_solid);
	drawCircle(flyctx, rotate(fly.leftOuterCenter, fly.spokeAngle), fly.outerHoleRadius, "black", fill_none, pattern_solid);

	// Redraw the hole distance lines in black, but keep them dotted
	drawCircle(flyctx, center, fly.innerHoleDistance, "black", fill_none, pattern_dot);
	drawCircle(flyctx, center, fly.outerHoleDistance, "black", fill_none, pattern_dot);

	// Radial dimensions from the center of the flywheel.
	// These are offset from the spokeAngle to get them out of the way of the
	// detail dimensions for cutting the webs.
	
	// Inner hole distance
	drawRadialDim(flyctx, center, fly.spokeAngle + 10,
			0, fly.innerHoleDistance,
			fly.innerHoleDistance.toFixed(lendigits), 0.75,	"black", pattern_solid);
	// Outer hole distance
	drawRadialDim(flyctx, center, fly.spokeAngle + 22.5,
			0, fly.outerHoleDistance,
			fly.outerHoleDistance.toFixed(lendigits), 0.75,
			"black", pattern_solid);
	// Rim radius
	drawRadialDim(flyctx, center, fly.spokeAngle + 32.5,
			0, fly.rimRadius,
			fly.rimRadius.toFixed(lendigits), 0.75,
			"black", pattern_solid);
	// Rim thickness
	var rim = fly.flywheelRadius - fly.rimRadius;
	drawRadialDim(flyctx, center, fly.spokeAngle + 28,
			fly.rimRadius, fly.flywheelRadius,
			rim.toFixed(lendigits), 0.50,
			"black", pattern_solid);
	// Flywheel Radius dimension (do we need diameter?)
	drawRadialDim(flyctx, center, fly.spokeAngle + 40,
			0, fly.flywheelRadius,
			fly.flywheelRadius.toFixed(lendigits), 0.70,
			"black", pattern_solid);
	
	// Hub Radius dimension is only useful as feedback from settings.
	// I place it as the last dimension and push out the label since I
	// know space is always going to be tight for the dimension to fit.
	drawRadialDim(flyctx, center, fly.spokeAngle + 75,
			0, fly.hubRadius,
			fly.hubRadius.toFixed(lendigits), 0.80,
			"black", pattern_solid);

	// Outer hole angle.  Draw this in the first web cutout.
	drawAngDim(flyctx, center, 0, fly.rightOuterAngle,
		fly.flywheelRadius,
		fly.rightOuterAngle.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);
	
	if (fly.leftOuterAngle != fly.rightOuterAngle) {  // should always be true
		drawAngDim(flyctx, center, 0, fly.spokeAngle + fly.leftOuterAngle,
			fly.flywheelRadius * 0.95,
			(fly.spokeAngle + fly.leftOuterAngle).toFixed(angdigits) + DEGSYM, 0.98,
			"black", pattern_solid);
	}
	
	// Inner hole angle.  Draw this in the first web cutout.
	drawAngDim(flyctx, center, 0, fly.rightInnerAngle,
		fly.flywheelRadius * 0.50,
		fly.rightInnerAngle.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);
	
	if (fly.leftInnerAngle != fly.rightInnerAngle) {
		// Second Inner hole angle.  Draw this in the first web cutout.
		drawAngDim(flyctx, center, 0, fly.spokeAngle + fly.leftInnerAngle,
			fly.flywheelRadius * 0.60,
			(fly.spokeAngle + fly.leftInnerAngle).toFixed(angdigits) + DEGSYM, 0.98,
			"black", pattern_solid);
	}	


	// Flywheel spoke angle.  Draw this in the last web cutout.
	drawAngDim(flyctx, center, -fly.spokeAngle, 0,
		fly.flywheelRadius * 0.91,
		fly.spokeAngle.toFixed(angdigits) + DEGSYM, 0.98,
		"black", pattern_solid);

	// Add degree marks for each spoke.  Only valuable for straight spokes
	if (fly.curveAngle == 0) {
		flyctx.context.save();
		var spk;
		var thisangle = 0;
		for (spk=0; spk < fly.numSpokes; spk++) {
			var label = thisangle.toFixed(angdigits) + DEGSYM;
			var textwidth = flyctx.context.measureText(label).width;
			var dest = rotate(toPoint(0, fly.flywheelRadius*flyctx.fscale * 1.07), thisangle);
			flyctx.context.fillText(label, flyctx.offsetx+dest.x - textwidth/2, flyctx.offsety-dest.y);
			thisangle += fly.spokeAngle;
		}
		flyctx.context.restore();
	}
}

//
// Draw the Step N figure for the straight spoke cutting setup figures.
//
// We draw a very simplified flywheel for this.  The main idea is to show
// what the setup movements are to avoid any chance of confusion.
//
// Step one shows the initial setup.  We have the flywheel centered with
// spoke 1 "up".  It shows the inner/outer holes and the cut line we are
// trying to establish.
//
function drawStraightSpokeStep(step, canvas, fly) {

	/* QQQ: There are some manually coded drawing steps here that need to be fixed.
	 */
	var context = canvas.getContext("2d");
	var offsetx = canvas.width / 2;
	var offsety = canvas.height / 2;
	var fradius =  Math.min(canvas.width, canvas.height) * 0.90 / 2;
	var fscale = fradius / fly.flywheelRadius;
	
	var flyctx = makeDrawingContext(canvas, fly.flywheelRadius);
	var center = toPoint(0,0);

	var cutangle = 0;
	var cutshift = 0;
	
	if (step > 1) {
		cutangle = 360-fly.rightCutAngle;
		if (cutangle == 360)
			cutangle = 0;	// more sane
	}
	
	if (step > 2) {
		// Calculate cut shift (cuts.x)
		var cuts = rotate(fly.rightCutEdgeStart, cutangle);
		cutshift = cuts.x;
	}
	
	if (step > 3) {
		// Further shift to show endmill radius adjustment
		cutshift += 3/fscale;
	}
	
	// Assigning to canvas.width will clear it
	canvas.width = canvas.width;
	
	// Draw the circle representing the flywheel
	drawCircle(flyctx, center, fly.flywheelRadius, "black", "lightgray", pattern_solid);
	drawCircle(flyctx, center, fly.rimRadius, "black", "white", pattern_solid);
	drawCircle(flyctx, center, fly.hubRadius, "black", "white", pattern_solid);
	drawCircle(flyctx, center, fly.shaftRadius, "black", "gray", pattern_solid);
	
	// Draw the mill's cut line
	drawLine(flyctx, toPoint(cutshift,0), toPoint(cutshift, fly.flywheelRadius*1.10), "blue", pattern_solid);

	context.save();
	// Draw a label saying it is the mill's cut line
	context.translate(offsetx+cutshift*fscale,offsety);	// Now 0,0 is the center.
	context.rotate(Math.PI/2);  // turn 90 degrees
	context.fillStyle = "blue";
	context.fillText("mill cut line", 20, -2);
	context.restore();

	// Draw the spoke 0 reference line
	drawRadialLine(flyctx, center, cutangle,
				fly.flywheelRadius*1.10,		// +10% gets it beyond the rim
				"black", pattern_dash_dot_dot);

	// Draw the inner/outer holes.
	var inctr = rotate(fly.rightInnerCenter, cutangle);
	var outctr = rotate(fly.rightOuterCenter, cutangle);
	drawCircle(flyctx, inctr, fly.innerHoleRadius, "black", fill_none, pattern_solid);
	drawCircle(flyctx, outctr, fly.outerHoleRadius,	"black", fill_none, pattern_solid);

	// Now draw the cut line in red
	// This has already been completely calculated in the spkinfo
	// but it needs rotation.
	var start = rotate(fly.rightCutEdgeStart, cutangle);
	var end = rotate(fly.rightCutEdgeEnd, cutangle);
	drawLine(flyctx, start, end, "red", pattern_solid);

	//
	// Step-specific markings.
	//
	if (step == 2) {
			// Draw rotation arc arrow.  This is not to any scale.
			var endang = 45;
			var flip = 1;	// multiplier -- no flip
			if (cutangle > 180) {
				endang = 315;  // arc all the way around for emphasis
				flip = -1;	// used for flipping the sign for the arrow math
			}
			context.beginPath();
			context.arc(offsetx,offsety,fradius*1.07,-Math.PI/2.5,degreesToRadians(endang-90));
			// We end at 45 degrees.  Make a 45 degree arrowhead which is
			// easy because it is straight up/down and left/right
			end = rotate(toPoint(0,fradius*1.07), endang);
			context.moveTo(offsetx+end.x, offsety-end.y);
			context.lineTo(offsetx+end.x, offsety-end.y-5*flip);
			context.moveTo(offsetx+end.x, offsety-end.y);
			context.lineTo(offsetx+end.x-5, offsety-end.y);
			context.stroke();
	}
	if (step > 2) {
			// Draw shift arrow.  This is not to any scale.
			context.beginPath();
			context.moveTo(canvas.width-10, 20);
			context.lineTo(canvas.width-40, 20);
			context.lineTo(canvas.width-36, 16);
			context.moveTo(canvas.width-40, 20);
			context.lineTo(canvas.width-36, 24);
			context.stroke();
	}

}


/*
 * Draw a picture of the fixture layout.
 */
function drawCurvedFixtureLayout(canvas, fly) {
	var flyctx = makeDrawingContext(canvas, fly.flywheelRadius)
	canvas.width = canvas.width // reset
	
	// Rescale this figure since we aren't drawing a flywheel.
	// Make it fit within 10% of the canvas we are given.
	var sz = fly.fixtureSize
	flyctx.fscale = (Math.min(canvas.width/sz.x, canvas.height/sz.y))*0.90
	flyctx.offsetx = canvas.width*0.05
	flyctx.offsety = canvas.height*0.95

	// Draw rectangle that represents the fixture.  A drawRect() would be handy.
	drawLine(flyctx, toPoint(0,0), toPoint(0,sz.y), "black", pattern_solid)
	drawLine(flyctx, toPoint(0,sz.y), sz, "black", pattern_solid)
	drawLine(flyctx, sz, toPoint(sz.x,0), "black", pattern_solid)
	drawLine(flyctx, toPoint(sz.x,0), toPoint(0,0), "black", pattern_solid)
	
	var ptA = addPoints(fly.fixtureOffset, fly.fixtureA);
	var ptB = addPoints(fly.fixtureOffset, fly.fixtureB);
	var ptC = addPoints(fly.fixtureOffset, fly.fixtureC);
	var ptD = addPoints(fly.fixtureOffset, fly.fixtureD);

	// Now draw A, B, C, D
	drawCircle(flyctx, ptA, 2/flyctx.fscale, "black", "black", pattern_solid)
	drawCircle(flyctx, ptB, 2/flyctx.fscale, "black", "black", pattern_solid)
	drawCircle(flyctx, ptC, 2/flyctx.fscale, "black", "black", pattern_solid)
	drawCircle(flyctx, ptD, 2/flyctx.fscale, "black", "black", pattern_solid)

	drawText(flyctx, ptA, toPoint(-10,2), "A")
	drawText(flyctx, ptB, toPoint(-10,2), "B")
	drawText(flyctx, ptC, toPoint(-10,2), "C")
	drawText(flyctx, ptD, toPoint(2,-10), "D")
}

/*
 * Draw a picture of the fixture placement under the flywheel.
 * The flag rightleft has this meaning:
 *	0:	draw with no cutting arc shown.
 *	1:  draw with the left arc shown.
 *  2:	draw with the right arc shown.
 */
function drawCurvedFixturePlacement(rightleft, canvas, fly) {

	var flyctx = makeDrawingContext(canvas, fly.flywheelRadius)
	var center = toPoint(0,0)

	/* First, draw dim demo by drawing a transparent white rectangle over it.  Cool, no? :) */
	drawFlywheelDemo(canvas, fly)
	flyctx.context.save()
	flyctx.context.fillStyle="white"
	flyctx.context.globalAlpha="0.65"
	flyctx.context.fillRect(0,0,canvas.width,canvas.height)
	flyctx.context.restore()
	
	// Now rotate the fixture to match the figure so we can draw it.
	// Call the corners JKLM, starting with J=bottom-left and going clockwise.
	var ang = fly.fixtureAngle
	var sz = fly.fixtureSize
	var shft = fly.fixtureOffset  // rotate around the ptA offset -- the flywheel center
	var ptJ = rotate(subtractPoints(shft, toPoint(0,0)), -ang)
	var ptK = rotate(subtractPoints(shft, toPoint(0,sz.y)), -ang)
	var ptL = rotate(subtractPoints(shft, sz), -ang)
	var ptM = rotate(subtractPoints(shft, toPoint(sz.x, 0)), -ang)
	
	drawLine(flyctx, ptJ, ptK, "black", pattern_solid)
	drawLine(flyctx, ptK, ptL, "black", pattern_solid)
	drawLine(flyctx, ptL, ptM, "black", pattern_solid)
	drawLine(flyctx, ptM, ptJ, "black", pattern_solid)
	
	switch (rightleft) {
		case 0:
			// Do nothing.
			break
		case 1:
			// Left arc drawn.
			drawArc(flyctx, fly.curveCutLeftCenter, fly.curveRadius,
					fly.curveCutLeftStartAngle, fly.curveCutLeftEndAngle,
					"black", pattern_solid);
			drawRadialLine(flyctx, fly.curveCutLeftCenter, fly.curveCutLeftStartAngle, fly.curveRadius,
					"gray", pattern_solid);
			drawRadialLine(flyctx, fly.curveCutLeftCenter, fly.curveCutLeftEndAngle, fly.curveRadius,
					"gray", pattern_solid);
			break
		case 2:
			// right arc drawn
			drawArc(flyctx, fly.curveCutRightCenter, fly.curveRadius,
					fly.curveCutRightStartAngle, fly.curveCutRightEndAngle,
					"black", pattern_solid);
			drawRadialLine(flyctx, fly.curveCutRightCenter, fly.curveCutRightStartAngle, fly.curveRadius,
					"gray", pattern_solid);
			drawRadialLine(flyctx, fly.curveCutRightCenter, fly.curveCutRightEndAngle, fly.curveRadius,
					"gray", pattern_solid);
			break
	}

	drawCircle(flyctx, toPoint(0,0), 1/flyctx.fscale, "black", "black", pattern_solid)
	drawCircle(flyctx, fly.locationPinCenter, 1/flyctx.fscale, "black", "black", pattern_solid)
	drawCircle(flyctx, fly.curveCutRightCenter, 2/flyctx.fscale, "blue", "blue", pattern_solid)
	drawCircle(flyctx, fly.curveCutLeftCenter, 2/flyctx.fscale, "green", "green", pattern_solid)

	drawText(flyctx, toPoint(0,0), toPoint(-10,2), "A")
	drawText(flyctx, fly.locationPinCenter, toPoint(-10,2), "B")
	drawText(flyctx, fly.curveCutRightCenter, toPoint(-20,5), "C")
	drawText(flyctx, fly.curveCutLeftCenter, toPoint(10,-15), "D")
}
</script>

</body>
</html>